<HTML>
<HEAD>
<TITLE>HL7 Version 2.x: Control: Conformance</TITLE>
<LINK REL="stylesheet" HREF="formate.css" type="text/css"><LINK REL="SHORTCUT ICON" HREF="hl7.ico"><META NAME="COPYRIGHT" CONTENT="(C) Health Level Seven, Int. 2017" /><META NAME="Generator" CONTENT="HL7 Comprehensive Database: DocxExtractor" /><META NAME="Author" CONTENT="Frank Oemig" /></HEAD>
<BODY>
<H1>
Table of Contents
</H1>
<UL>
<LI><A HREF="ch02B.html#Heading854">2B Control: Conformance</A></LI>
<UL>
<LI><A HREF="ch02B.html#Heading855">2B.1 Chapter 2B Contents</A></LI>
<LI><A HREF="ch02B.html#Heading856">2B.2 Purpose  </A></LI>
<UL>
<LI><A HREF="ch02B.html#Heading857">2B.2.1 Message profile  </A></LI>
<LI><A HREF="ch02B.html#Heading858">2B.2.2 Message profile identifier</A></LI>
<LI><A HREF="ch02B.html#Heading859">2B.2.3 Message profile publish/subscribe topics</A></LI>
</UL>
<LI><A HREF="ch02B.html#Heading860">2B.3 Interaction Definition  </A></LI>
<LI><A HREF="ch02B.html#Heading861">2B.4 Dynamic definition  </A></LI>
<UL>
<LI><A HREF="ch02B.html#Heading862">2B.4.1 Interaction model  </A></LI>
<LI><A HREF="ch02B.html#Heading863">2B.4.2 Acknowledgements  </A></LI>
</UL>
<LI><A HREF="ch02B.html#Heading864">2B.5 Static definition  </A></LI>
<UL>
<LI><A HREF="ch02B.html#Heading865">2B.5.1 Static definition identifier</A></LI>
<LI><A HREF="ch02B.html#Heading866">2B.5.2 Static definition publish/subscribe topics</A></LI>
</UL>
<LI><A HREF="ch02B.html#Heading867">2B.6 Table definition  </A></LI>
<UL>
<LI><A HREF="ch02B.html#Heading868">2B.6.1 Table Library</A></LI>
<UL>
<LI><A HREF="ch02B.html#Heading869">2B.6.1.0 Table Library Meta Data</A></LI>
<LI><A HREF="ch02B.html#Heading870">2B.6.1.1 Table Definition</A></LI>
</UL>
<LI><A HREF="ch02B.html#Heading871">2B.6.2 Conformance Requirements</A></LI>
</UL>
<LI><A HREF="ch02B.html#Heading872">2B.7 Profile type  </A></LI>
<UL>
<LI><A HREF="ch02B.html#Heading873">2B.7.1 Vendor constrainable profiles   </A></LI>
<LI><A HREF="ch02B.html#Heading874">2B.7.2 Realm constrainable profiles   </A></LI>
<LI><A HREF="ch02B.html#Heading875">2B.7.3 Implementation profiles   </A></LI>
</UL>
<LI><A HREF="ch02B.html#Heading876">2B.8 Static definition concepts  </A></LI>
<UL>
<LI><A HREF="ch02B.html#Heading877">2B.8.1 Length </A></LI>
<LI><A HREF="ch02B.html#Heading878">2B.8.2 Conformance Length </A></LI>
<LI><A HREF="ch02B.html#Heading879">2B.8.3 Truncation Flag </A></LI>
<LI><A HREF="ch02B.html#Heading880">2B.8.4 Cardinality  </A></LI>
<LI><A HREF="ch02B.html#Heading881">2B.8.5 Usage  </A></LI>
<UL>
<LI><A HREF="ch02B.html#Heading882">2B.8.5.0 Definition of Conditional Usage</A></LI>
</UL>
<LI><A HREF="ch02B.html#Heading883">2B.8.6 Relationship between HL7 optionality and conformance usage</A></LI>
<LI><A HREF="ch02B.html#Heading884">2B.8.7 Relationship between usage and cardinality</A></LI>
<LI><A HREF="ch02B.html#Heading885">2B.8.8 Usage within hierarchical elements</A></LI>
<LI><A HREF="ch02B.html#Heading886">2B.8.9 Condition predicate</A></LI>
<LI><A HREF="ch02B.html#Heading887">2B.8.10 Annotation</A></LI>
</UL>
<LI><A HREF="ch02B.html#Heading888">2B.9 Static definition - message level  </A></LI>
<UL>
<LI><A HREF="ch02B.html#Heading889">2B.9.1 Segment definitions</A></LI>
<LI><A HREF="ch02B.html#Heading890">2B.9.2 Segment usage </A></LI>
<LI><A HREF="ch02B.html#Heading891">2B.9.3 Segment cardinality</A></LI>
<LI><A HREF="ch02B.html#Heading892">2B.9.4 Field definitions</A></LI>
<LI><A HREF="ch02B.html#Heading893">2B.9.5 Field cardinality</A></LI>
<LI><A HREF="ch02B.html#Heading894">2B.9.6 Field usage </A></LI>
<LI><A HREF="ch02B.html#Heading895">2B.9.7 Data type</A></LI>
<LI><A HREF="ch02B.html#Heading896">2B.9.8 Length</A></LI>
<LI><A HREF="ch02B.html#Heading897">2B.9.9 Conformance Length</A></LI>
<LI><A HREF="ch02B.html#Heading898">2B.9.10 Table reference</A></LI>
</UL>
<LI><A HREF="ch02B.html#Heading899">2B.10 Static definition - field level  </A></LI>
<UL>
<LI><A HREF="ch02B.html#Heading900">2B.10.1 Field Definitions</A></LI>
<LI><A HREF="ch02B.html#Heading901">2B.10.2 User-defined and suggested field values</A></LI>
<LI><A HREF="ch02B.html#Heading902">2B.10.3 Constant values</A></LI>
<LI><A HREF="ch02B.html#Heading903">2B.10.4 Data values</A></LI>
<LI><A HREF="ch02B.html#Heading904">2B.10.5 Pattern Matching</A></LI>
<LI><A HREF="ch02B.html#Heading905">2B.10.6 Element Relationships</A></LI>
<LI><A HREF="ch02B.html#Heading906">2B.10.7 Profiling Multiple Occurrences</A></LI>
<LI><A HREF="ch02B.html#Heading907">2B.10.8 Components and subcomponents</A></LI>
</UL>
<LI><A HREF="ch02B.html#Heading908">2B.11 Message profile document  </A></LI>
<UL>
<LI><A HREF="ch02B.html#Heading909">2B.11.1 Message profile document format</A></LI>
<LI><A HREF="ch02B.html#Heading910">2B.11.2 Message profile document definition</A></LI>
</UL>
<LI><A HREF="ch02B.html#Heading911">2B.12 Documentation</A></LI>
<UL>
<LI><A HREF="ch02B.html#Heading912">2B.12.1 Documentation Hierarchy</A></LI>
<LI><A HREF="ch02B.html#Heading913">2B.12.2 Introduction</A></LI>
<LI><A HREF="ch02B.html#Heading914">2B.12.3 Problem Space</A></LI>
<LI><A HREF="ch02B.html#Heading915">2B.12.4 Hierarchy of Profiles</A></LI>
<LI><A HREF="ch02B.html#Heading916">2B.12.5 Architecture</A></LI>
<LI><A HREF="ch02B.html#Heading917">2B.12.6 Components</A></LI>
<LI><A HREF="ch02B.html#Heading918">2B.12.7 Relationships</A></LI>
<LI><A HREF="ch02B.html#Heading919">2B.12.8 Testing Types</A></LI>
<LI><A HREF="ch02B.html#Heading920">2B.12.9 Documentation Quality</A></LI>
<LI><A HREF="ch02B.html#Heading921">2B.12.10 Impacts</A></LI>
<LI><A HREF="ch02B.html#Heading922">2B.12.11 Primary Focus of Requirement</A></LI>
<LI><A HREF="ch02B.html#Heading923">2B.12.12 Advantages for Implementers</A></LI>
</UL>
<LI><A HREF="ch02B.html#Heading924">2B.13 Tools  </A></LI>
<LI><A HREF="ch02B.html#Heading925">2B.14 Conformity Assessment of Usage Codes</A></LI>
<UL>
<LI><A HREF="ch02B.html#Heading926">2B.14.1 Conformity Assessment of Usage Codes</A></LI>
<LI><A HREF="ch02B.html#Heading927">2B.14.2 Usage – Sending Application</A></LI>
<UL>
<LI><A HREF="ch02B.html#Heading928">2B.14.2.0 Conditional (C(a/b)) Usage Conformity Assessment</A></LI>
<LI><A HREF="ch02B.html#Heading929">2B.14.2.1 Optional (O) Usage Conformance Implications</A></LI>
</UL>
<LI><A HREF="ch02B.html#Heading930">2B.14.3 Usage – Receiving Application</A></LI>
<UL>
<LI><A HREF="ch02B.html#Heading931">2B.14.3.0 Conditional (C(a/b)) Usage Conformity Assessment</A></LI>
<LI><A HREF="ch02B.html#Heading932">2B.14.3.1 Optional (O) Usage Conformance Implications</A></LI>
</UL>
</UL>
<LI><A HREF="ch02B.html#Heading933">2B.15 Message profile document definition </A></LI>
<UL>
<LI><A HREF="ch02B.html#Heading934">2B.15.1 Message profile schema  </A></LI>
<LI><A HREF="ch02B.html#Heading935">2B.15.2 Table Librarydocument definition</A></LI>
</UL>
</UL>
</UL>
<p>
ANSI/HL7 V2.9-2019
</p>
<p>
12/9/2019
</p>
<A ID="Heading854" >
<H1>
2B Control: Conformance
</H1>
<p>
2
</p>
<TABLE>
<TR>
<TD>
<p>
Chapter Chair
</p>
</TD>
<TD>
<p>
Frank OemigDeutsche Telekom Healthcare Security Solutions GmbH
</p>
</TD>
</TR>
<TR>
<TD>
<p>
Chapter Chair
</p>
</TD>
<TD>
<p>
Robert SnelickNational Institute of Standards and Technology (NIST)
</p>
</TD>
</TR>
<TR>
<TD>
<p>
Chapter Chair
</p>
</TD>
<TD>
<p>
Ioana Singureanu
</p>
</TD>
</TR>
<TR>
<TD>
<p>
Chapter Chair
</p>
</TD>
<TD>
<p>
Nathan BunkerAmerican Immunization Registry Assoication (AIRA)
</p>
</TD>
</TR>
<TR>
<TD>
<p>
Sponsoring Work Group:
</p>
</TD>
<TD>
<p>
Conformance 
</p>
</TD>
</TR>
<TR>
<TD>
<p>
List Server:
</p>
</TD>
<TD>
<p>
cgit@lists.hl7.org 
</p>
</TD>
</TR>
</TABLE>
<A ID="Heading855" >
<H2>
2B.1 Chapter 2B Contents
</H2>
<A ID="Heading856" >
<H2>
2B.2 Purpose  
</H2>
<p>
Previous sections in this chapter define the rules and conventions for constructing and communicating a message including the parts of a message structure. Messages that adhere to those rules of a specific version of a standard are compliant to that version of the standard.
</p>
<p>
Compliance to the HL7 Standard has historically been impossible to define and measure in a meaningful way. To compensate for this shortcoming, vendors and sites have used various methods of specifying boundary conditions such as optionality and cardinality. Frequently, specifications have given little guidance beyond the often-indefinite constraints provided in the HL7 Standard.
</p>
<p>
This section presents the methodology for producing a precise and unambiguous specification of a single interaction called a message profile. Messages that adhere to the constraints of a message profile are said to be conformant to the profile. For conformance to be measurable, the message profile must specify the following types of information:
</p>
<p>
What data will be passed in a message.
</p>
<p>
The format in which the data will be passed.
</p>
<p>
The acknowledgement responsibilities of the sender and receiver.
</p>
<p>
A conformance statement is a claim that the behavior of an application or application module agrees with the constraints stated in one or more message profiles. This section defines the message profile; however, the conformance statement will not be discussed further in this document.
</p>
<p>
An implementation guide is often created to organize a collection of message profiles for specifying a set of related HL7 V2.x interactions described in a use case. Implementation guides typically describe broader conformance requirements such as application behavior. Such requirements may include how a set of messages are to be used to enact certain application functionality. Implementation guides, which have broad scope have been introduced in this section to provide context of message profiles and will not be discussed further in this document. A message profile provides a mechanism for specifying a single message definition.
</p>
<p>
Definition:  An HL7 message profile is an unambiguous specification of one standard HL7 message that has been analyzed for a particular interaction. It prescribes a set of precise constraints upon this HL7 message.
</p>
<p>
An HL7 message profile is compliant, in all aspects, with the HL7 defined message(s) used in the profile. It may specify constraints on the standard HL7 message definition.
</p>
<p>
A message profile fully describes a conversation between two or more systems through the combination of the following:
</p>
<p>
one interaction analysis, 
</p>
<p>
one or more dynamic definitions,
</p>
<p>
one static definition, and
</p>
<p>
one table (vocabulary) definition.
</p>
<p>
The interaction analysis may be documented as a sequence diagram (supported with text) or just a textual description (See section 2.B.2, "Interaction Definition".)
</p>
<p>
The dynamic definition is an interaction specification for a conversation between 2 or more systems (See Section 2.B.3, "Dynamic definition".)
</p>
<p>
The static definition is a specification that defines the constraints for a single message structure (see Section 2.B.4, "Static definition"). 
</p>
<p>
The table (vocabulary) definition is  a specification of the tables referenced in the static definition.  (see Section 2.B.5, "Table definition"). 
</p>
<p>
The message profile is normatively expressed as an XML document validated against the normative message profile Schema, which may be registered on the HL7 web site (see Section 2.B.10, "Message profile document"). The normative table definition can partly or wholly be contained in the message profile XML document. The table definition can also be partly or wholly defined in a table library. The table library is normatively expressed as an XML document validated against the normative table library Schema, which may be registered on the HL7 web site  (see Section 2.B.10, "Message profile document").
</p>
<p>
For detailed background information regarding message profiles, the reader is referred to the Implementation/Conformance Work Group balloted informative document, "Message Profiling Specification, Version 2.2", published November 30, 2000, upon which this section is based. This document is available from the HL7 Resources Web site (http://www.hl7.org).
</p>
<p>
A sample message profile is shown on the next page to assist in illustrating the constituents of a message profile and how they work together.
</p>
<p>
Message Profile Example
</p>
<img src="ch02b_3.png" />
<A ID="Heading857" >
<H3>
2B.2.1 Message profile  
</H3>
<p>
Definition: An HL7 message profile is an unambiguous specification of one  standard HL7 message that has been analyzed for a particular interaction. Each message profile may have a unique identifier as well as publish/subscribe topics.
</p>
<A ID="Heading858" >
<H3>
2B.2.2 Message profile identifier
</H3>
<p>
Each message profile may have a unique identifier to facilitate reference.
</p>
<A ID="Heading859" >
<H3>
2B.2.3 Message profile publish/subscribe topics
</H3>
<p>
The message profile publish/subscribe topics is not required to be unique but might be used by publish/subscribe systems to convey aspects of the message profile (see MSH-21 Message Profile Identifier in the opening section of chapter 2).
</p>
<p>
The topics are not a normative constituent of the message profile but, if provided as part of the metadata, should be in the format described below. The topic elements will be separated by the dash (-).  Any element that does not have a value should use null. As this information may be used in a message instance; it should not contain any HL7 message delimiters.
</p>
<p>
Message Profile Publish/Subscribe Topics Elements
</p>
<TABLE border=1>
<TR>
<TD>
<p>
Seq
</p>
</TD>
<TD>
<p>
Topic Element Name
</p>
</TD>
<TD>
<p>
Value
</p>
</TD>
</TR>
<TR>
<TD>
<p>
1
</p>
</TD>
<TD>
<p>
Implementation/Conformance Work Group ID
</p>
</TD>
<TD>
<p>
Confsig
</p>
</TD>
</TR>
<TR>
<TD>
<p>
2
</p>
</TD>
<TD>
<p>
An organization identifier
</p>
</TD>
<TD>
<p>
Abbreviated version of the organization name
</p>
</TD>
</TR>
<TR>
<TD>
<p>
3
</p>
</TD>
<TD>
<p>
The HL7 version
</p>
</TD>
<TD>
<p>
Refer to HL7 Table 0104 - Version ID for valid values
</p>
</TD>
</TR>
<TR>
<TD>
<p>
4
</p>
</TD>
<TD>
<p>
Topic Type
</p>
</TD>
<TD>
<p>
Profile
</p>
</TD>
</TR>
<TR>
<TD>
<p>
5
</p>
</TD>
<TD>
<p>
Accept Acknowledgement
</p>
</TD>
<TD>
<p>
The accept acknowledgement responsibilities.(refer to HL7 Table 0155  Accept/application Acknowledgment Conditions for valid values)
</p>
</TD>
</TR>
<TR>
<TD>
<p>
6
</p>
</TD>
<TD>
<p>
Application Acknowledgement
</p>
</TD>
<TD>
<p>
The application acknowledgement responsibilities (refer to HL7 Table 0155  Accept/application Acknowledgment Conditions for valid values)
</p>
</TD>
</TR>
<TR>
<TD>
<p>
7
</p>
</TD>
<TD>
<p>
Acknowledgement Mode
</p>
</TD>
<TD>
<p>
Deferred or Immediate
</p>
</TD>
</TR>
</TABLE>
<p>
An example of message profile publish/subscribe topics:
</p>
<p>
confSig-MyOrganization-2.4-profile-AL-NE-Immediate
</p>
<A ID="Heading860" >
<H2>
2B.3 Interaction Definition  
</H2>
<p>
Definition: An interaction definition documents the scope and requirements for an HL7 message profile.
</p>
<p>
The interaction definition must:
</p>
<p>
Provide a name that clearly and concisely defines the exchange
</p>
<p>
Document the purpose for the message exchange
</p>
<p>
Define the actors, including the sending and receiving applications
</p>
<p>
Define the flow of events between these actors including, where appropriate, derived events 
</p>
<p>
Document the situations in which the exchange of a particular HL7 message profile is required
</p>
<A ID="Heading861" >
<H2>
2B.4 Dynamic definition  
</H2>
<p>
Definition: The dynamic definition is an interaction specification for a conversation between 2 or more systems. It may reference one static definition. The dynamic definition may include an interaction model in addition to the acknowledgement responsibilities. 
</p>
<A ID="Heading862" >
<H3>
2B.4.1 Interaction model  
</H3>
<p>
Definition: The Interaction Model illustrates the sequence of trigger events and resulting message flows between 2 or more systems. It may be in literal or graphical form. Graphical form should be a UML activity diagram. Example activity diagrams are shown here for the original and enhanced acknowledgement modes.
</p>
<p>
Interaction Model Example  ADT^A01/ACK^A01 (Original Acknowledgement Mode)
</p>
<img src="ch02b_4.png" />
<p>
Interaction Model Example  ADT^A01/ACK^A01 (Enhanced Acknowledgement Mode)
</p>
<img src="ch02b_5.png" />
<A ID="Heading863" >
<H3>
2B.4.2 Acknowledgements  
</H3>
<p>
The specific HL7 acknowledgements required and/or allowed for use with the specified static definition of the HL7 message profile shall be defined. Specifically, the dynamic definition shall identify whether an accept and/or application level acknowledgement is allowed or required.
</p>
<p>
For any one static definition there may be one or more dynamic definition. 
</p>
<p>
The dynamic definition shall define the conditions under which an accept and/or application level acknowledgement is expected.
</p>
<p>
Allowed conditions include:
</p>
<p>
Always
</p>
<p>
Never
</p>
<p>
Only on success
</p>
<p>
Only on error.
</p>
<A ID="Heading864" >
<H2>
2B.5 Static definition  
</H2>
<p>
Definition: The static definition is an exhaustive specification for a single message. Normatively expressed in XML, it may be registered on the HL7 web site (See Section 2.B.10, "Message profile document"). The static definition is based on a message structure defined in the HL7 Standard. The message code, trigger event, event description, role (Sender or Receiver) and, if applicable, the order control code will be provided. A complete static definition shall be defined at the message, segment, and field levels. A static definition is compliant in all aspects with the HL7-defined message it profiles. However, the static definition may define additional constraints on the standard HL7 message.
</p>
<p>
A static definition identifies only those specific elements of a standard HL7 message that are used in the exchange.
</p>
<p>
A static definition explicitly defines:
</p>
<p>
Segments, segment groups, fields and components usage rules
</p>
<p>
Cardinalities 
</p>
<p>
Length information
</p>
<p>
Value sets and coding systems.
</p>
<p>
The following figure depicts, in a graphical way, the concept that the static definition is an overlay of the HL7 message structure further constraining it. For example, where the HL7 message structure shows unlimited number of NK1 Segments, the static definition allows for only three repetitions. Additionally, fields that are optional in the HL7 message structure may be required within the HL7 static definitions.
</p>
<p>
Static Definition Illustration
</p>
<img src="ch02b_6.png" />

<A ID="Heading865" >
<H3>
2B.5.1 Static definition identifier
</H3>
<p>
Each static definition must have a unique identifier when registered (See section 2.B.10, "Message profile document"). An authority other than the registry may define this identifier. If, at the time of registration, the static profile does not have an identifier assigned by the submitter''s authority, the registry authority will assign one. The static definition identifier would be the identifier used if a system asserts a strict conformance claim (see MSH-21 Message Profile Identifier in the first section of chapter 2).
</p>
<A ID="Heading866" >
<H3>
2B.5.2 Static definition publish/subscribe topics
</H3>
<p>
Static definition publish/subscribe topics convey the static definition aspects of the message profile. These topics may be used by publish/subscribe systems (see MSH-21 Message Profile Identifier in the first section of chapter 2). 
</p>
<p>
The topics are not a normative constituent of the message profile but, if provided as part of the metadata (see section 2.B.10, "Message profile document"), should be in the format described below. The topic elements will be separated by the dash (-). Any element that does not have a value should be null (nothing between the dashes). As this information may be used in a message instance, it should not contain any HL7 message delimiters.
</p>
<p>
Static Definition Publish/Subscribe Topics Components
</p>
<TABLE  border=1>
<TR>
<TD>
<p>
Seq
</p>
</TD>
<TD>
<p>
Topic element name
</p>
</TD>
<TD>
<p>
Value(s)
</p>
</TD>
</TR>
<TR>
<TD>
<p>
1
</p>
</TD>
<TD>
<p>
Implementation/Conformance Work Group ID
</p>
</TD>
<TD>
<p>
confsig
</p>
</TD>
</TR>
<TR>
<TD>
<p>
2
</p>
</TD>
<TD>
<p>
An organization identifier
</p>
</TD>
<TD>
<p>
Abbreviated version of the organization name
</p>
</TD>
</TR>
<TR>
<TD>
<p>
3
</p>
</TD>
<TD>
<p>
The HL7 version
</p>
</TD>
<TD>
<p>
Refer to HL7 Table 0104  Version ID for valid values
</p>
</TD>
</TR>
<TR>
<TD>
<p>
4
</p>
</TD>
<TD>
<p>
Topic Type
</p>
</TD>
<TD>
<p>
static
</p>
</TD>
</TR>
<TR>
<TD>
<p>
5
</p>
</TD>
<TD>
<p>
Message Type Code 
</p>
</TD>
<TD>
<p>
Refer to HL7 Table 0076 - Message type for valid values
</p>
</TD>
</TR>
<TR>
<TD>
<p>
6
</p>
</TD>
<TD>
<p>
Event Type 
</p>
</TD>
<TD>
<p>
Refer to HL7 Table 0003 - Event Type for valid values (this table may be extended by locally defined Z trigger events)
</p>
</TD>
</TR>
<TR>
<TD>
<p>
7
</p>
</TD>
<TD>
<p>
Order Control Code 
</p>
</TD>
<TD>
<p>
Refer to HL7 Table 0119 - Order Control Codes for valid values
</p>
</TD>
</TR>
<TR>
<TD>
<p>
8
</p>
</TD>
<TD>
<p>
Structure Type 
</p>
</TD>
<TD>
<p>
Refer to HL7 Table 0354 - Message Structure for valid values (this table may extended by locally defined message structures)
</p>
</TD>
</TR>
<TR>
<TD>
<p>
9
</p>
</TD>
<TD>
<p>
Specification Version 
</p>
</TD>
<TD>
<p>
Version number of the application, interface, or specification
</p>
</TD>
</TR>
<TR>
<TD>
<p>
10
</p>
</TD>
<TD>
<p>
Specification Status
</p>
</TD>
<TD>
<p>
Status of the application, interface, or specification
</p>
</TD>
</TR>
<TR>
<TD>
<p>
11
</p>
</TD>
<TD>
<p>
Role
</p>
</TD>
<TD>
<p>
Sender or Receiver
</p>
</TD>
</TR>
</TABLE>
<p>
An example of static definition publish/subscribe topics:
</p>
<p>
confsig-MyOrganization-2.4-static-ADT-A04--ADT_A01-v2-draft-Sender
</p>
<A ID="Heading867" >
<H2>
2B.6 Table definition  
</H2>
<p>
The table definition (or vocabulary) is a specification of a collection of tables used to constrain coded message element content.  The table definition is an independent specification that can be embedded in a message profile or referenced by one or more message profiles.  Each table definition consists of meta data and code/description pairs. A coded message element is associated with a table in the static definition with the "table" attribute for fields, components, and sub-components. Elements that use coded data types  (e.g., CNE, CWE, etc.) are also associated with a table. For the latter, the message includes the code, drawn from HL7 Table 0396  Coding System in Chapter 2C, Code Tables, that uniquely defines the table respective coding system, as well as the coded value itself.
</p>
<A ID="Heading868" >
<H3>
2B.6.1 Table Library
</H3>
<p>
The table definition defines a vocabulary that can be bound to a message profile.  The table library specifies a standardized format to organize the vocabulary and provides support to reference it (See section 2.B.2.14). In short, the table library is a container for a collection of tables. Note that the table definition may also be embedded in the XML message profile. A table library is organized as follows:
</p>
<p>
Table library meta data
</p>
<p>
Collection of tables and their values
</p>
<p>
The table library supports references to tables and instances of tables. 
</p>
<A ID="Heading869" >
<H4>
2B.6.1.0 Table Library Meta Data
</H4>
<p>
The following table describes the table library meta data. Definitions for each attribute are given.
</p>
<p>
Table Library Meta Data
</p>
<TABLE border=1>
<TR>
<TD>
<p>
Attributes
</p>
</TD>
<TD>
<p>
Definition
</p>
</TD>
<TD>
<p>
Example/Enumerations
</p>
</TD>
</TR>
<TR>
<TD>
<p>
Name
</p>
</TD>
<TD>
<p>
The name of the table library.
</p>
</TD>
<TD>
<p>
AdminMessagesVocabulary
</p>
</TD>
</TR>
<TR>
<TD>
<p>
OrganizationName
</p>
</TD>
<TD>
<p>
The organization that created the library.
</p>
</TD>
<TD>
<p>
ABC Medical Group
</p>
</TD>
</TR>
<TR>
<TD>
<p>
TableLibraryVersion
</p>
</TD>
<TD>
<p>
The version of the table library.
</p>
</TD>
<TD>
<p>
1.2
</p>
</TD>
</TR>
<TR>
<TD>
<p>
Status
</p>
</TD>
<TD>
<p>
The status of the table library.
</p>
</TD>
<TD>
<p>
D (Development), A (Active), I (Inactive)
</p>
</TD>
</TR>
<TR>
<TD>
<p>
TableLibraryIdentifier
</p>
</TD>
<TD>
<p>
A unique identifier for the table library.
</p>
</TD>
<TD>
<p>
2.16.840.1.113883.3.72.4.2.134
</p>
</TD>
</TR>
<TR>
<TD>
<p>
Description
</p>
</TD>
<TD>
<p>
A text description of the table library.
</p>
</TD>
<TD>
<p>
The Admin Table library provides the vocabulary for our patient registration application (supporting the following message profile events: ADT^A01, ADT^A04, ADT^A08, and ADT^A40).
</p>
</TD>
</TR>
</TABLE>
<A ID="Heading870" >
<H4>
2B.6.1.1 Table Definition
</H4>
<p>
A table definition consists of metadata describing the table and specifies a list of code/value pairs.  The table definition metadata consists of a table identifier, OID, name, type, version, and code system.  Table elements express code/description pairs.  The Table below gives a summary of each table definition attribute along with an example.  The table type is a recognized HL7 table as described in section 2.C.1  Code Tables: Definitions. Valid identifiers for a table type are HL7, User, Local, External, and Imported.  
</p>
<p>
Table Definition for HL7 Tables
</p>
<TABLE border=1>
<TR>
<TD>
<p>
Table Attribute
</p>
</TD>
<TD>
<p>
Definition
</p>
</TD>
<TD>
<p>
Example
</p>
</TD>
</TR>
<TR>
<TD>
<p>
Identifier
</p>
</TD>
<TD>
<p>
The table identifier
</p>
</TD>
<TD>
<p>
0001
</p>
</TD>
</TR>
<TR>
<TD>
<p>
OID
</p>
</TD>
<TD>
<p>
An OID that identifies the table, not the code system
</p>
</TD>
<TD>
<p>
2.16.840.1.113883.12.1
</p>
</TD>
</TR>
<TR>
<TD>
<p>
Name
</p>
</TD>
<TD>
<p>
A descriptive name of the table
</p>
</TD>
<TD>
<p>
Administrative Sex
</p>
</TD>
</TR>
<TR>
<TD>
<p>
Type
</p>
</TD>
<TD>
<p>
The type of the table as described in section 2.6.3.6
</p>
</TD>
<TD>
<p>
HL7
</p>
</TD>
</TR>
<TR>
<TD>
<p>
Version
</p>
</TD>
<TD>
<p>
The version of the table
</p>
</TD>
<TD>
<p>
1.0
</p>
</TD>
</TR>
<TR>
<TD>
<p>
Code System
</p>
</TD>
<TD>
<p>
A code system as specified in the HL7 table 0396
</p>
</TD>
<TD>
<p>
2.5.1
</p>
</TD>
</TR>
</TABLE>
<p>
A table element consists of a code, display name (value), and source. The table below gives a summary of each table element attribute along with an example.  Valid identifiers for the table element source are HL7, Local, Redefined, or Standard Development Organization (SDO).  Redefined means the code/display name has been changed from its original value.
</p>
<p>
Table Definition for Other Tables
</p>
<TABLE border=1>
<TR>
<TD>
<p>
Element Attribute
</p>
</TD>
<TD>
<p>
Definition
</p>
</TD>
<TD>
<p>
Example
</p>
</TD>
</TR>
<TR>
<TD>
<p>
Code
</p>
</TD>
<TD>
<p>
The code for the data value
</p>
</TD>
<TD>
<p>
M
</p>
</TD>
</TR>
<TR>
<TD>
<p>
Display Name
</p>
</TD>
<TD>
<p>
The long description of the code
</p>
</TD>
<TD>
<p>
Male
</p>
</TD>
</TR>
<TR>
<TD>
<p>
Source
</p>
</TD>
<TD>
<p>
The source of the code/value pair
</p>
</TD>
<TD>
<p>
HL7
</p>
</TD>
</TR>
</TABLE>
<A ID="Heading871" >
<H3>
2B.6.2 Conformance Requirements
</H3>
<p>
The content of a table definition is used to express conformance requirements of coded message elements defined in a message profile.  If the content of a coded message element matches that of a table element defined in the table definition identified with the Table attribute, the content of the message element is said to be conformant with respect to the message profile. If the content of a coded message element does not match a table element defined in the table definition identified with the Table attribute, the content of the message element is said to be non-conformant with respect to the message profile.
</p>
<A ID="Heading872" >
<H2>
2B.7 Profile type  
</H2>
<p>
There are three basic profile types used in documenting standard conformance:
</p>
<p>
HL7 Standard profile (represents a specific HL7 published standard, creation and publication limited to HL7 use),
</p>
<p>
constrainable profile (with "Optional" elements which must be further constrained in order to create implementation profiles), and
</p>
<p>
implementation profile (no "Optional" parts, fully implementable).
</p>
<p>
This model allows vendors, SDOs, PEOs or providers to publish generic profiles from which fully constrained implementation profiles can be created.
</p>
<p>
In comparison with the HL7 standard, separate constrainable and implementation profiles may exist for the receiving and the sending role.
</p>
<A ID="Heading873" >
<H3>
2B.7.1 Vendor constrainable profiles   
</H3>
<p>
A vendor might develop a message profile to which all their software products must comply but, in itself, is not an implementation profile. The different products serve potentially different domains and might be implemented with products from other vendors. The vendor profile constrains the HL7 Standard by defining agreed-to vocabularies, conditionality rules, supported items, and local extensions that are shared across all products. The profile is not necessarily fully constrained. For example, the vendor profile might allow the usage code of optional as, across different products, an element may be required in some use cases, be optional or conditional in others, and not be supported at all in still others. Furthermore, at this level, providing exact length definition is optional as well.
</p>
<p>
The vendor''s individual software products might themselves have profiles that would build on, and further constrain, their vendor profile. The product profile would specifically define the information model and the elements contained within. The product profile might still be a constrainable profile as elements might result in different HL7 messages based on configuration settings and customizations. Only once all configuration settings and customizations have been taken into account can you have a fully-constrained ''Implementation'' profile.
</p>
<p>
Constrainable profiles can be useful for interface engine applications which must be flexible enough to allow for receipt of messages based on a variety of message profiles.  The desire of the application would be to validate message instances against one constrainable profile.
</p>
<A ID="Heading874" >
<H3>
2B.7.2 Realm constrainable profiles   
</H3>
<p>
Realm, national and regional, profiles represent localization and restrictions placed on the appropriate standard, while providing enough optionality for basing the more specific implementation profiles. Some examples of realm constrainable profiles are:
</p>
<p>
AS4700.1-2001 Implementation of HL7 v2.3.1 Part 1:Patient Administration (constrainable profile for Australian Standards, constrains HL7 2.3.1, Chapter 3).
</p>
<p>
AS/NZS 4700.3-1999 Implementation of HL7 v2.3 Part 3: Electronic messages for exchange of information on Drug Prescription (constrainable profile for Australian Standards, constrains HL7 2.3, various Chapters).
</p>
<A ID="Heading875" >
<H3>
2B.7.3 Implementation profiles   
</H3>
<p>
Implementation profiles represent the lowest level of specification required for unambiguous implementation. Examples of some implementation profiles are:
</p>
<p>
Adverse Drug Reaction Implementers Specification, 2001, TGA (implementation profile, constrains Australian Standards and HL7 v2.3.1 constrainable profiles for Therapeutic Goods Administration ADRAC Messaging Implementation Project),
</p>
<p>
Diabetes Reporting Implementers Specification, 2001, UNSW (implementation profile, constrains Australian Standards and HL7 v2.3.1 constrainable profiles for University of NSW Diabetes Messaging Implementation Project),
</p>
<p>
Specific version of a product, as implemented, at a specific provider.
</p>
<p>
Within an implementation profile the exact length definition must be provided.
</p>
<A ID="Heading876" >
<H2>
2B.8 Static definition concepts  
</H2>
<p>
This section discusses concepts common to each level of the static definition (message, segment and field). It uses the generic term ''element'' to refer to segment groups, segments, fields, components and sub-components.
</p>
<A ID="Heading877" >
<H3>
2B.8.1 Length 
</H3>
<p>
An unambiguous definition of length requires a clear understanding of what it applies to and how it is measured.  Length is defined to be a constraint on the number of characters that may be present in one occurrence of a message element. This definition satisfies both requirements; it applies (strictly) to an element''s data valuei.e., the set of characters present in the message representing a value of the element''s predefined data typeand it is measured in characters as defined by the rules in chapter 2.  The definition is system independent.  For example, a system that encodes characters using one byte and a system that uses two-byte encoding would use the same value for length to impose the same length constraint. Length does not count the HL7 characters used to represent the value, only the number of characters in the value itself is counted.  If the null character is represented by transmitting "", length conforms to any minimum and maximum length specification. 
</p>
<p>
Length shall be interpreted as a restriction on an element''s data value, not on the presence or absence of the element.  A length value of zero is appropriate when the null character is transmitted, but this does not imply the element is not present; clearly two characters will be present if null is transmitted.  Restricting the applicability of length to data values present in the message is necessary.  Not only does it keep the concept simple and eliminate the need to address special cases, it also allows for the transmission of null values for required elements.  A required element can have a null value, since this still clearly means there is a data value encoded for the element in the message.  If an element is empty or not present in the message, i.e., there is no data value encoded for the element in the message, then length restrictions do not apply since there is nothing to restrict and no length constraint that can be violated.  
</p>
<p>
Length shall be specified using the following syntax: "m..n", where m and n are non-negative integers designating the minimum and maximum number of characters the element may have, respectively, where n  m. When an upper bound for length cannot be determined in advance, the use of the asterisk character, "*", may be used as a place holder for the maximum value, so that, in addition, to the above syntax, where m and n are integer values, a constraint of the form "m..*" may be used to indicate the maximum length constraint is unknown.
</p>
<p>
Example length constraints are shown in the Minimum and Maximum Length Examples table.
</p>
<p>
Minimum and Maximum Length Examples
</p>
<TABLE border=1>
<TR>
<TD>
<p>
Value
</p>
</TD>
<TD>
<p>
Description
</p>
</TD>
<TD>
<p>
Comment
</p>
</TD>
</TR>
<TR>
<TD>
</TD>
<TD>
<p>
For constrainable profile: no length defined, i.e. no requirements on the length are given.
</p>
<p>
Leaving this information empty is not allowed for implementable profiles. 
</p>
</TD>
<TD>
</TD>
</TR>
<TR>
<TD>
<p>
0..0
</p>
</TD>
<TD>
<p>
For withdrawn elements:  minimum and maximum set to 0.
</p>
</TD>
<TD>
</TD>
</TR>
<TR>
<TD>
<p>
1..1
</p>
</TD>
<TD>
<p>
Element must have exactly one character
</p>
</TD>
<TD>
</TD>
</TR>
<TR>
<TD>
<p>
1..n
</p>
</TD>
<TD>
<p>
Element may have up to n characters
</p>
</TD>
<TD>
</TD>
</TR>
<TR>
<TD>
<p>
n..n
</p>
</TD>
<TD>
<p>
Element must have exactly "n" characters
</p>
</TD>
<TD>
</TD>
</TR>
<TR>
<TD>
<p>
1..*
</p>
</TD>
<TD>
<p>
Element may have any length.
</p>
</TD>
<TD>
</TD>
</TR>
<TR>
<TD>
<p>
n..*
</p>
</TD>
<TD>
<p>
Element may have any length which is greater than or equal to "n", where "n" is greater than or equal to 1.
</p>
</TD>
<TD>
</TD>
</TR>
<TR>
<TD>
<p>
m..n
</p>
</TD>
<TD>
<p>
Element must have a minimum length of "m" and a maximum length of "n" where "m" is less than or equal to "n" and "m" is greater than or equal to 1.
</p>
</TD>
<TD>
</TD>
</TR>
</TABLE>
<p>
Note: Whether or not an element is populated is controlled by cardinality. But if the element is populated with a non-null value, the minimum and maximum length definition must hold. The null information representation (two double quotes) is not considered to be a value with applicable length information.
</p>
<p>
Length should not be specified for composite elements. In these cases, the actual minimum and maximum lengths can be very difficult to determine due to the interdependencies on the component content, and the specification of actual lengths is not useful either. For example, if an overall length of 4..20 is assigned to a data element with a type CWE, what does this mean in practice? However if a length is specified, the vertical bar representation of the data must conform to the stated length, allowing for an additional character for each HL7 separator character.
</p>
<A ID="Heading878" >
<H3>
2B.8.2 Conformance Length 
</H3>
<p>
Constrainable profile specifications may also specify a conformance length. This is the number of characters that any conformant application must be able to correctly handle.  For example, a constrainable profile may declare that the minimum and maximum lengths of a specific field are 3 and 2500. An implementation profile may further constrain this length to specify what is actually supported by an application. However an application could declare a length of 3..4, which may not be useful within the context of the constrainable profile. A constrainable profile may specify conformance lengths to establish a minimum expectation. In the example case, if the constrainable profile specifies a conformance length of 200, no other profile may assert conformance to the constrainable profile unless its maximum length is 200 or greater.
</p>
<p>
Conformance length is a redundant concept in implementation profiles that will not be further constrained, and should not be specified. 
</p>
<A ID="Heading879" >
<H3>
2B.8.3 Truncation Flag 
</H3>
<p>
As of 2.7, a truncation pattern is defined which can be used to assist applications to manage the existence of data that exceeds the maximum number of characters that can be properly handled. The truncation pattern is described in Chapter 2, section 2.5.5.2, "Truncation Pattern". Note that the actual truncation behavior of the pattern is data type dependent. Applications shall not use truncation if the profile prohibits it. Applications may support truncation if the profile permits it.  Message Profiles may specify the truncation behaviour.
</p>
<p>
The truncation flag is a simple Boolean. In a constrainable profile, the value may be true or false. False signifies that the element may not be truncated, while true means that the value may be truncated. If a profile fixes truncation to false, no other further constraining profile may mark this value as true. If the value is fixed to true, other further constraining profiles may mark it as true or false. 
</p>
<p>
In an implementation profile, a value of true for the truncation flag signifies that the application supports the defined truncation behavior for the appropriate type. A value of false indicates that the application does not support data truncation for this element.
</p>
<p>
Although the truncation pattern was only defined in v2.7, the behavior may be adopted for previous versions of HL7, and the truncation flag may be used with previous version. Note that in these cases, the truncation character cannot be specified in the message, and some other arrangement must exist.
</p>
<A ID="Heading880" >
<H3>
2B.8.4 Cardinality  
</H3>
<p>
In order to separate message content requirements from application behavior requirements, cardinality is used to control message content, and usage is used to define application requirements. Cardinality controls the number of occurrences of an element appearing in a message. Some elements shall always be present (e.g., cardinality [1..1], [1..n]). Others shall never be present (i.e., cardinality [0..0]). Others may be optional with zero or more occurrences (e.g., cardinality [0..n]). Cardinality identifies the minimum and maximum number of occurrences that a message element must have in a conformant message. Cardinalities are expressed as a minimum-maximum pair of non-negative integers. A conformant message must always contain at least the minimum number of occurrences, and shall not contain more than the maximum number of occurrences.
</p>
<p>
An explicit cardinality range is required for segment group, segment, and field elements.  Component and sub-component elements do not explicitly include a cardinality range, but a cardinality range is implicitly associated with each component and sub-component element.  The associated cardinality depends on the element''s usage code.  For components and sub-components with a usage code of R, the associated cardinality range is [1..1]; for all elements with a usage code of RE or O, the associated cardinality is [0..1]; for all elements with a usage code of C(a/b), the associated cardinality is determined by the resultant usage based on the evaluation of the condition predicate, and for all elements with an X usage code, the associated cardinality is [0..0].
</p>
<p>
There are two special values for cardinality. If the minimum number of occurrences is 0, the element may be omitted from a message. In certain circumstances, the maximum number of occurrences may have no specified limit. In this case, it is identified with "*" (e.g., [n..*]).  
</p>
<p>
Valid cardinality values are shown in the Cardinality table; combinations not designated in the table are invalid. In particular, usage code RE is not allowed with cardinalities [1..1], [1..n], and [1..*].  Cardinality [m..n], where m is greater than 1, is allowed with usage codes R and RE.  If an element with this cardinality range has a usage code RE, the element may be omitted from the message but if present, it must have at least m occurrences and may not have more than n occurrences.
</p>
<p>
Cardinality
</p>
<TABLE>
<TR>
<TD>
<p>
Value
</p>
</TD>
<TD>
<p>
Description
</p>
</TD>
<TD>
<p>
Valid Usage Codes
</p>
</TD>
<TD>
<p>
Comment
</p>
</TD>
</TR>
<TR>
<TD>
<p>
[0..0]
</p>
</TD>
<TD>
<p>
Element never present
</p>
</TD>
<TD>
<p>
X
</p>
</TD>
<TD>
</TD>
</TR>
<TR>
<TD>
<p>
[0..1]
</p>
</TD>
<TD>
<p>
Element may be omitted and it can have at most one occurrence
</p>
</TD>
<TD>
<p>
RE, O, C(a/b)
</p>
</TD>
<TD>
</TD>
</TR>
<TR>
<TD>
<p>
[1..1]
</p>
</TD>
<TD>
<p>
Element must have exactly one occurrence
</p>
</TD>
<TD>
<p>
R 
</p>
</TD>
<TD>
</TD>
</TR>
<TR>
<TD>
<p>
[0..n]
</p>
</TD>
<TD>
<p>
Element may be omitted or may have up to n occurrences
</p>
</TD>
<TD>
<p>
RE, O, C(a/b)
</p>
</TD>
<TD>
</TD>
</TR>
<TR>
<TD>
<p>
[1..n]
</p>
</TD>
<TD>
<p>
Element must appear at least once, and may have up to n occurrences
</p>
</TD>
<TD>
<p>
R 
</p>
</TD>
<TD>
</TD>
</TR>
<TR>
<TD>
<p>
[0..*]
</p>
</TD>
<TD>
<p>
Element may be omitted or may have an unlimited number of occurrences
</p>
</TD>
<TD>
<p>
RE, O, C(a/b)
</p>
</TD>
<TD>
</TD>
</TR>
<TR>
<TD>
<p>
[1..*]
</p>
</TD>
<TD>
<p>
Element must appear at least once, and may have an unlimited number of occurrences
</p>
</TD>
<TD>
<p>
R 
</p>
</TD>
<TD>
</TD>
</TR>
<TR>
<TD>
<p>
[m..n] 
</p>
</TD>
<TD>
<p>
Element must have at least "m" occurrences and may have at most "n" occurrences. Except that in the case where the usage code is RE, the element may also be omitted or have zero occurrences
</p>
</TD>
<TD>
<p>
R and RE
</p>
</TD>
<TD>
</TD>
</TR>
<TR>
<TD>
<p>
[m..*]3
</p>
</TD>
<TD>
<p>
Element must have at least "m" occurrences and may have an unlimited number of occurrences.  Except that in the case where the usage code is RE, the element may also be omitted or have zero occurrences.
</p>
</TD>
<TD>
<p>
R and RE
</p>
</TD>
<TD>
</TD>
</TR>
</TABLE>
<A ID="Heading881" >
<H3>
2B.8.5 Usage  
</H3>
<p>
Message content is governed by the cardinality specification associated (explicitly or implicitly) with each element of an HL7 message. Usage rules govern the expected behavior of the sending application and receiving application with respect to the element. The usage codes expand/clarify the optionality codes defined in the HL7 standard.  Usage codes are employed in a message profile to constrain the use of elements defined in the standard. The usage code definitions are given from a sender and receiver perspective and specify implementation and operational requirements.
</p>
<p>
The standard allows broad flexibility for the message structures that HL7 applications must be able to receive without failing. But while the standard allows that messages may be missing data elements or may contain extra data elements, it should not be inferred from this requirement that such messages are conformant.  In fact, the usage codes specified in a message profile place strict conformance requirements on the behavior of the application.
</p>
<A ID="Heading882" >
<H4>
2B.8.5.0 Definition of Conditional Usage
</H4>
<p>
The conditional usage is defined as follows:
</p>
<p>
C(a/b) - "a" and "b" in the expression are placeholders for usage codes representing the true ("a") predicate outcome and the false ("b") predicate outcome of the condition. The condition is expressed by a conditional predicate associated with the element ("See section 2.B.7.9, "Condition predicate"). "a" and "b" shall be one of "R", "RE", "O" and/or "X". The values of "a" and "b" can be the same. 
</p>
<p>
The example C(R/RE) is interpreted as follows. If the condition predicate associated with the element is true then the usage for the element is R-Required. If the condition predicate associated with the element is false then the usage for the element is RE-Required but may be empty. 
</p>
<p>
There are cases where it is appropriate to value "a" and "b" the same. For example, the base standard defines the usage of an element as "C" and the condition predicate is dependent on the presence or non-presence of another element. The profile may constrain the element that the condition is dependent on to X; in such a case the condition should always evaluate to false. Therefore, the condition is profiled to C(X/X) since the desired effect is for the element to be not supported. Note it is not appropriate (in this case) to profile the element to X since this breaks the rules of allowable usage profiling (see table HL7 Optionality and Conformance Usage).
</p>
<p>
Usage Rules for a Sending Application
</p>
<TABLE border=1>
<TR>
<TD>
<p>
Optionality/Usage Indicator
</p>
</TD>
<TD>
<p>
Description
</p>
</TD>
<TD>
<p>
Implementation Requirement
</p>
</TD>
<TD>
<p>
Operational Requirement
</p>
</TD>
</TR>
<TR>
<TD>
<p>
R
</p>
</TD>
<TD>
<p>
Required
</p>
</TD>
<TD>
<p>
The application shall implement "R" elements. 
</p>
</TD>
<TD>
<p>
The application shall populate "R" elements with a non-empty value.
</p>
</TD>
</TR>
<TR>
<TD>
<p>
RE
</p>
</TD>
<TD>
<p>
Required but may be empty
</p>
</TD>
<TD>
<p>
The application shall implement "RE" elements.
</p>
</TD>
<TD>
<p>
The application shall populate "RE" elements with a non-empty value if there is relevant data. The term "relevant" has a confounding interpretation in this definition. 
</p>
</TD>
</TR>
<TR>
<TD>
<p>
C(a/b)
</p>
</TD>
<TD>
<p>
Conditional
</p>
</TD>
<TD>
<p>
An element with a conditional usage code has an associated condition predicate (See section 2.B.7.9, "Condition predicate") that determines the requirements (usage code) of the element.
</p>
<p>
If the condition predicate associated with the element is true, follow the rules for a which shall be one of "R", "RE", "O" or X":
</p>
<p>
If the condition predicate associated with the element is false, follow the rules for b which shall be one of "R", "RE", "O" or X".
</p>
<p>
a and b can be valued the same.
</p>
</TD>
</TR>
<TR>
<TD>
<p>
X
</p>
</TD>
<TD>
<p>
Not supported
</p>
</TD>
<TD>
<p>
The application (or as configured) shall not implement "X" elements.
</p>
</TD>
<TD>
<p>
The application shall not populate "X" elements.
</p>
</TD>
</TR>
<TR>
<TD>
<p>
O
</p>
</TD>
<TD>
<p>
Optional
</p>
</TD>
<TD>
<p>
None. The usage indicator for this element has not yet been defined. For an implementation profile all optional elements must be profiled to R, RE, C(a/b) or X.
</p>
</TD>
<TD>
<p>
Not Applicable. 
</p>
</TD>
</TR>
</TABLE>
<p>
Usage Rules for a Receiving Application
</p>
<TABLE border=1>
<TR>
<TD>
<p>
Optionality/Usage  Indicator
</p>
</TD>
<TD>
<p>
Description
</p>
</TD>
<TD>
<p>
Implementation Requirement
</p>
</TD>
<TD>
<p>
Operational Requirement
</p>
</TD>
</TR>
<TR>
<TD>
<p>
R
</p>
</TD>
<TD>
<p>
Required
</p>
</TD>
<TD>
<p>
The application shall implement "R" elements. 
</p>
</TD>
<TD>
<p>
The receiving application shall process (save/print/archive/etc.) the information conveyed by a required element.
</p>
<p>
A receiving application shall raise an exception due to the absence of a required element. A receiving application shall not raise an error due to the presence of a required element,
</p>
</TD>
</TR>
<TR>
<TD>
<p>
RE
</p>
</TD>
<TD>
<p>
Required but may be empty
</p>
</TD>
<TD>
<p>
The application shall implement "RE" elements.
</p>
</TD>
<TD>
<p>
The receiving application shall process (save/print/archive/etc.) the information conveyed by a required but may be empty element. The receiving application shall process the message if the element is omitted (that is, an exception shall not be raised because the element is missing).
</p>
</TD>
</TR>
<TR>
<TD>
<p>
C(a/b)
</p>
</TD>
<TD>
<p>
Conditional
</p>
</TD>
<TD>
<p>
An element with a conditional usage code has an associated condition predicate (See section 2.B.7.9, "Condition predicate") that determines the requirements (usage code) of the element.
</p>
<p>
If the condition predicate associated with the element is true, follow the rules for a which shall be one of "R", "RE", "O" or X":
</p>
<p>
If the condition predicate associated with the element is false, follow the rules for b which shall be one of "R", "RE", "O" or X".
</p>
<p>
a and b can be valued the same.
</p>
</TD>
</TR>
<TR>
<TD>
<p>
X
</p>
</TD>
<TD>
<p>
Not supported
</p>
</TD>
<TD>
<p>
The application (or as configured) shall not implement "X" elements.
</p>
</TD>
<TD>
<p>
None, if the element is not sent.
</p>
<p>
If the element is sent the receiving application may process the message, shall ignore the element, and may raise an exception. The receiving application shall not process (save/print/archive/etc.) the information conveyed by a not-supported element.
</p>
</TD>
</TR>
<TR>
<TD>
<p>
O
</p>
</TD>
<TD>
<p>
Optional
</p>
</TD>
<TD>
<p>
None. The usage indicator for this element has not yet been defined. For an implementation profile all optional elements must be profiled to R, RE, C(a/b), or X.
</p>
</TD>
<TD>
<p>
None. 
</p>
</TD>
</TR>
</TABLE>
<A ID="Heading883" >
<H3>
2B.8.6 Relationship between HL7 optionality and conformance usage
</H3>
<p>
Conformance usage codes are more specific than HL7 Optionality codes. Because of the requirement that conformance statements must be compliant with the HL7 message definition it is derived from, there are restrictions on what usage codes may be assigned to an element based on the HL7 Optionality. For example, any element designated as required in a standard HL7 message definition shall also be required in all HL7 message profiles of that standard message.
</p>
<p>
HL7 Optionality and Conformance Usage
</p>
<TABLE border=1>
<TR>
<TD>
<p>
Base Optionality/Usage
</p>
</TD>
<TD>
<p>
Derived (Constrained) Optionality/ Usage
</p>
</TD>
<TD>
<p>
Comment
</p>
</TD>
</TR>
<TR>
<TD>
<p>
R - Required
</p>
</TD>
<TD>
<p>
R
</p>
</TD>
<TD>
</TD>
</TR>
<TR>
<TD>
<p>
RE - Required but may be empty
</p>
</TD>
<TD>
<p>
RE, R
</p>
</TD>
<TD>
</TD>
</TR>
<TR>
<TD>
<p>
O - Optional
</p>
</TD>
<TD>
<p>
R, RE, O, C(a/b), X
</p>
</TD>
<TD>
<p>
O is only permitted for constrainable profiles
</p>
</TD>
</TR>
<TR>
<TD>
<p>
C - Conditional
</p>
</TD>
<TD>
<p>
C(a/b),R
</p>
</TD>
<TD>
<p>
"a" and "b" shall be one of "R", "RE", "O" or "X". "a" and "b" can be valued the same.
</p>
</TD>
</TR>
<TR>
<TD>
<p>
X  Not Supported
</p>
</TD>
<TD>
<p>
X
</p>
</TD>
<TD>
</TD>
</TR>
<TR>
<TD>
<p>
B  Backward Compatibility
</p>
</TD>
<TD>
<p>
R, RE, O, C(a/b), X
</p>
</TD>
<TD>
<p>
B is only permitted for constrainable definitions
</p>
</TD>
</TR>
<TR>
<TD>
<p>
W - Withdrawn
</p>
</TD>
<TD>
<p>
X
</p>
</TD>
<TD>
</TD>
</TR>
</TABLE>
<p>
Conformance usage codes can also be further constrained in subsequence constrainable or implementation profiles. The allowed conformance usage profiling  table indicates the how the conformance usage codes can be further constrained.
</p>
<p>
Allowed Conformance Usage Profiling
</p>
<TABLE border=1>
<TR>
<TD>
<p>
Conformance Usage
</p>
</TD>
<TD>
<p>
Constrained Possibilities
</p>
</TD>
<TD>
<p>
Comment
</p>
</TD>
</TR>
<TR>
<TD>
<p>
R - Required
</p>
</TD>
<TD>
<p>
R
</p>
</TD>
<TD>
</TD>
</TR>
<TR>
<TD>
<p>
RE - Required but may be empty
</p>
</TD>
<TD>
<p>
RE, R
</p>
</TD>
<TD>
</TD>
</TR>
<TR>
<TD>
<p>
C(a/b)
</p>
</TD>
<TD>
<p>
Follow the rules for R, RE, and X in this table as they apply to a and b.
</p>
</TD>
<TD>
<p>
For example, C(RE/X) can be further constrained to C(R/X).
</p>
</TD>
</TR>
<TR>
<TD>
<p>
X  Not Supported
</p>
</TD>
<TD>
<p>
X
</p>
</TD>
<TD>
</TD>
</TR>
</TABLE>
<p>
Note:
</p>
<p>
The conditional usage construct shall not be nested.
</p>
<p>
The condition in the derived profile shall not modify the condition in the base profile. The exception is a removal of the condition in a derived profile if it can be constantly evaluated to either true or false and then be replaced by the appropriate usage code.
</p>
<A ID="Heading884" >
<H3>
2B.8.7 Relationship between usage and cardinality
</H3>
<p>
Cardinality governs the appearance of a field, and usage governs the expected behavior of applications.  Nevertheless, a relationship exists between them that must be maintained. The valid combinations of the two are defined in the Cardinality table. For purposes of message profiles, selected cardinality and usage combinations are examined here. The constraints on allowed combinations are:
</p>
<p>
If the usage of an element is Required (R), the minimum cardinality for the element shall always be greater than or equal to 1.
</p>
<p>
If the usage of an element is not Required (R) (i.e., any code other than ''R''), the minimum cardinality shall be 0 except in the following condition:
</p>
<p>
If the profile author wishes to express a circumstance where an element will not always be present, but when present must have a minimum number of repetitions greater than one, this may be indicated by specifying the non-required Usage code with the minimum cardinality representing the minimum number of repetitions when the element is present. This is accomplished, as in UML, with an expression of the form as (m..n), indicating that permitted occurrences are either zero, or the range of m through n.
</p>
<p>
Example combinations:
</p>
<p>
Example Usage-Cardinality Combinations
</p>
<TABLE border=1>
<TR>
<TD>
<p>
Cardinality
</p>
</TD>
<TD>
<p>
Usage
</p>
</TD>
<TD>
<p>
Interpretation
</p>
</TD>
</TR>
<TR>
<TD>
<p>
[1..1]
</p>
</TD>
<TD>
<p>
R
</p>
</TD>
<TD>
<p>
There will always be exactly 1 occurrence present.
</p>
</TD>
</TR>
<TR>
<TD>
<p>
[1..5]
</p>
</TD>
<TD>
<p>
R
</p>
</TD>
<TD>
<p>
There will be between 1 and 5 occurrences present.
</p>
</TD>
</TR>
<TR>
<TD>
<p>
[0..1]
</p>
</TD>
<TD>
<p>
RE
</p>
</TD>
<TD>
<p>
The element must be supported, but may not always be present.
</p>
</TD>
</TR>
<TR>
<TD>
<p>
[0..5]
</p>
</TD>
<TD>
<p>
C(R/X)
</p>
</TD>
<TD>
<p>
If the condition predicate is true, there will be between 1 and 5 occurrences. If the condition predicate is false, there will be 0 occurrences.
</p>
</TD>
</TR>
<TR>
<TD>
<p>
[3..5]
</p>
</TD>
<TD>
<p>
RE
</p>
</TD>
<TD>
<p>
If any values for the element are sent, there must be at least 3 and no more than 5 occurrences. However, the element may be absent (0 occurrences).
</p>
</TD>
</TR>
</TABLE>
<A ID="Heading885" >
<H3>
2B.8.8 Usage within hierarchical elements
</H3>
<p>
As part of the conformance framework, there is an additional rule for determining whether a particular ''element'' is present. The rule is as follows: For an element to be considered present, it must have content. This means that simple elements (fields, components or sub-components with simple data types such as NM, ST, ID) must have at least one character. Complex elements (those composed of other elements, e.g., Messages, Segment Groups, Segments, Fields with complex data types such as CNE, XPN, etc.), must contain at least one element that is present. Elements that do not meet these conditions are not considered to be present.
</p>
<p>
For example, if a field is made up of 4 required but may be empty components, at least one of the components must be present in order for the field to be considered present. Thus, if the field is profiled as Required, an instance message would only be conformant if the field contained at least one populated component. The reason for this rule is to ensure that the intent of the profile is met. The rule is necessary because the traditional ''vertical bar'' encoding allows, for example, for a bare segment identifier with no fields (e.g., a line containing just "NTE|" would be considered valid under the standard rules, but would be considered not present as far as testing against a conformance specification). The XML encoding also allows this, as well as fields without their components, components without their sub-components, etc. (e.g., &lt;PID.3/&gt;).
</p>
<A ID="Heading886" >
<H3>
2B.8.9 Condition predicate
</H3>
<p>
If the usage code of an element is C (i.e., C(a/b), then a conditionality predicate must be associated with this element that identifies the conditions under which the element must be or is allowed to be present. The predicate must be testable and based on other values within the message. This predicate may be expressed as a mathematical expression or in text and may utilize operators such as equivalence, logical AND, logical OR and NOT. The conforming sending and receiving applications shall both evaluate the predicate. When the Usage is not ''C'', the conditionality predicate will not be valued.
</p>
<A ID="Heading887" >
<H3>
2B.8.10 Annotation
</H3>
<p>
Annotations provide further explanations to educate prospective users and/or implementers. These are usually used to enhance the descriptions of the elements of the base specification in order to relate them to a particular context.
</p>
<p>
Types of annotations supported:
</p>
<p>
Definition: An explanation of the meaning of the element.
</p>
<p>
Description: An explanation of the associated element.  This may contain formatting markup.
</p>
<p>
Design Comment: Internal development note about why particular design decisions were made, outstanding issues and remaining work.  They may contain formatting markup.  Not intended for external publication.
</p>
<p>
Implementation Note: Implementation Notes provide a general description about how the element is intended to be used, as well as hints on using or interpreting the it.
</p>
<p>
Other Annotation: Additional content related to the element.
</p>
<p>
Example: An example instance
</p>
<p>
Added ability to communicate pattern matching and element relationships.  These, as well as condition predicate, will allow for text and formal testable constraints.
</p>
<A ID="Heading888" >
<H2>
2B.9 Static definition - message level  
</H2>
<p>
The message level static definition shall be documented using the HL7 abstract message syntax, with the addition of specifying cardinality and usage for each of the segments contained within the message structure.
</p>
<p>
The usage column (OPT) shall be updated to reflect the usage of the segment or group within this particular static definition.
</p>
<p>
The cardinality column shall accurately reflect the minimum and maximum number of occurences of the field allowed for the segment or group within this particular static definition.
</p>
<p>
Sample Static Definition - Message Level 
</p>
<TABLE border=1>
<TR>
<TD>
<p>
ADT^A01^ADT_A01
</p>
</TD>
<TD>
<p>
ADT Message
</p>
</TD>
<TD>
<p>
Status
</p>
</TD>
<TD>
<p>
Usage
</p>
</TD>
<TD>
<p>
Cardinality
</p>
</TD>
<TD>
<p>
Chapter
</p>
</TD>
</TR>
<TR>
<TD>
<p>
MSH
</p>
</TD>
<TD>
<p>
Message Header
</p>
</TD>
<TD>
</TD>
<TD>
<p>
R
</p>
</TD>
<TD>
<p>
[1..1]
</p>
</TD>
<TD>
<p>
2
</p>
</TD>
</TR>
<TR>
<TD>
<p>
[{ SFT }]
</p>
</TD>
<TD>
<p>
Software Segment
</p>
</TD>
<TD>
</TD>
<TD>
<p>
X
</p>
</TD>
<TD>
<p>
[0..0]
</p>
</TD>
<TD>
<p>
2
</p>
</TD>
</TR>
<TR>
<TD>
<p>
[ UAC ]
</p>
</TD>
<TD>
<p>
User Authentication Credential
</p>
</TD>
<TD>
</TD>
<TD>
<p>
X
</p>
</TD>
<TD>
<p>
[0..0]
</p>
</TD>
<TD>
<p>
2
</p>
</TD>
</TR>
<TR>
<TD>
<p>
EVN
</p>
</TD>
<TD>
<p>
Event Type
</p>
</TD>
<TD>
</TD>
<TD>
<p>
R
</p>
</TD>
<TD>
<p>
[1..1]
</p>
</TD>
<TD>
<p>
3
</p>
</TD>
</TR>
<TR>
<TD>
<p>
PID
</p>
</TD>
<TD>
<p>
Patient Identification
</p>
</TD>
<TD>
</TD>
<TD>
<p>
R
</p>
</TD>
<TD>
<p>
[1..1]
</p>
</TD>
<TD>
<p>
3
</p>
</TD>
</TR>
<TR>
<TD>
<p>
[  PD1  ]
</p>
</TD>
<TD>
<p>
Additional Demographics
</p>
</TD>
<TD>
</TD>
<TD>
<p>
X
</p>
</TD>
<TD>
<p>
[0..0]
</p>
</TD>
<TD>
<p>
3
</p>
</TD>
</TR>
<TR>
<TD>
<p>
[  ARV  ]
</p>
</TD>
<TD>
<p>
Access Restrictions
</p>
</TD>
<TD>
</TD>
<TD>
<p>
X
</p>
</TD>
<TD>
<p>
[0..0]
</p>
</TD>
<TD>
<p>
3
</p>
</TD>
</TR>
<TR>
<TD>
<p>
[{ ROL }]
</p>
</TD>
<TD>
<p>
Role
</p>
</TD>
<TD>
</TD>
<TD>
<p>
X
</p>
</TD>
<TD>
<p>
[0..0]
</p>
</TD>
<TD>
<p>
15
</p>
</TD>
</TR>
<TR>
<TD>
<p>
[{ NK1 }]
</p>
</TD>
<TD>
<p>
Next of Kin / Associated Parties
</p>
</TD>
<TD>
</TD>
<TD>
<p>
RE
</p>
</TD>
<TD>
<p>
[0..3]
</p>
</TD>
<TD>
<p>
3
</p>
</TD>
</TR>
<TR>
<TD>
<p>
   PV1
</p>
</TD>
<TD>
<p>
Patient Visit
</p>
</TD>
<TD>
</TD>
<TD>
<p>
C
</p>
</TD>
<TD>
<p>
[0..1]
</p>
</TD>
<TD>
<p>
3
</p>
</TD>
</TR>
<TR>
<TD>
<p>
[  ARV  ]
</p>
</TD>
<TD>
<p>
Access Restrictions
</p>
</TD>
<TD>
</TD>
<TD>
<p>
X
</p>
</TD>
<TD>
<p>
[0..0]
</p>
</TD>
<TD>
<p>
3
</p>
</TD>
</TR>
<TR>
<TD>
<p>
[  PV2  ]
</p>
</TD>
<TD>
<p>
Patient Visit - Additional Info.
</p>
</TD>
<TD>
</TD>
<TD>
<p>
RE
</p>
</TD>
<TD>
<p>
[0..1]
</p>
</TD>
<TD>
<p>
3
</p>
</TD>
</TR>
<TR>
<TD>
<p>
[{ ROL }]
</p>
</TD>
<TD>
<p>
Role
</p>
</TD>
<TD>
</TD>
<TD>
<p>
X
</p>
</TD>
<TD>
<p>
[0..0]
</p>
</TD>
<TD>
<p>
15
</p>
</TD>
</TR>
<TR>
<TD>
<p>
[{ DB1 }]
</p>
</TD>
<TD>
<p>
Disability Information
</p>
</TD>
<TD>
</TD>
<TD>
<p>
X
</p>
</TD>
<TD>
<p>
[0..0]
</p>
</TD>
<TD>
<p>
3
</p>
</TD>
</TR>
<TR>
<TD>
<p>
[{ OBX }]
</p>
</TD>
<TD>
<p>
Observation/Result
</p>
</TD>
<TD>
</TD>
<TD>
<p>
X
</p>
</TD>
<TD>
<p>
[0..0]
</p>
</TD>
<TD>
<p>
7
</p>
</TD>
</TR>
<TR>
<TD>
<p>
[{ AL1 }]
</p>
</TD>
<TD>
<p>
Allergy Information
</p>
</TD>
<TD>
</TD>
<TD>
<p>
RE
</p>
</TD>
<TD>
<p>
[0..10]
</p>
</TD>
<TD>
<p>
3
</p>
</TD>
</TR>
<TR>
<TD>
<p>
[{ DG1 }]
</p>
</TD>
<TD>
<p>
Diagnosis Information
</p>
</TD>
<TD>
</TD>
<TD>
<p>
X
</p>
</TD>
<TD>
<p>
[0..0]
</p>
</TD>
<TD>
<p>
6
</p>
</TD>
</TR>
<TR>
<TD>
<p>
[  DRG  ]
</p>
</TD>
<TD>
<p>
Diagnosis Related Group
</p>
</TD>
<TD>
</TD>
<TD>
<p>
X
</p>
</TD>
<TD>
<p>
[0..0]
</p>
</TD>
<TD>
<p>
6
</p>
</TD>
</TR>
<TR>
<TD>
<p>
[{
</p>
</TD>
<TD>
<p>
--- PROCEDURE begin
</p>
</TD>
<TD>
</TD>
<TD>
<p>
X
</p>
</TD>
<TD>
<p>
[0..0]
</p>
</TD>
<TD>
</TD>
</TR>
<TR>
<TD>
<p>
     PR1 
</p>
</TD>
<TD>
<p>
Procedures
</p>
</TD>
<TD>
</TD>
<TD>
<p>
X
</p>
</TD>
<TD>
<p>
[0..0]
</p>
</TD>
<TD>
<p>
6
</p>
</TD>
</TR>
<TR>
<TD>
<p>
  [{ ROL }]
</p>
</TD>
<TD>
<p>
Role
</p>
</TD>
<TD>
</TD>
<TD>
<p>
X
</p>
</TD>
<TD>
<p>
[0..0]
</p>
</TD>
<TD>
<p>
15
</p>
</TD>
</TR>
<TR>
<TD>
<p>
}]
</p>
</TD>
<TD>
<p>
--- PROCEDURE end
</p>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
</TR>
<TR>
<TD>
<p>
[{ GT1 }]
</p>
</TD>
<TD>
<p>
Guarantor
</p>
</TD>
<TD>
</TD>
<TD>
<p>
X
</p>
</TD>
<TD>
<p>
[0..0]
</p>
</TD>
<TD>
<p>
6
</p>
</TD>
</TR>
<TR>
<TD>
<p>
[{ 
</p>
</TD>
<TD>
<p>
--- INSURANCE begin
</p>
</TD>
<TD>
</TD>
<TD>
<p>
X
</p>
</TD>
<TD>
<p>
[0..0]
</p>
</TD>
<TD>
</TD>
</TR>
<TR>
<TD>
<p>
     IN1
</p>
</TD>
<TD>
<p>
Insurance
</p>
</TD>
<TD>
</TD>
<TD>
<p>
X
</p>
</TD>
<TD>
<p>
[0..0]
</p>
</TD>
<TD>
<p>
6
</p>
</TD>
</TR>
<TR>
<TD>
<p>
  [  IN2 ]
</p>
</TD>
<TD>
<p>
Insurance Additional Info.
</p>
</TD>
<TD>
</TD>
<TD>
<p>
X
</p>
</TD>
<TD>
<p>
[0..0]
</p>
</TD>
<TD>
<p>
6
</p>
</TD>
</TR>
<TR>
<TD>
<p>
  [{ IN3 }] 
</p>
</TD>
<TD>
<p>
Insurance Additional Info - Cert.
</p>
</TD>
<TD>
</TD>
<TD>
<p>
X
</p>
</TD>
<TD>
<p>
[0..0]
</p>
</TD>
<TD>
<p>
6
</p>
</TD>
</TR>
<TR>
<TD>
<p>
  [{ ROL }]
</p>
</TD>
<TD>
<p>
Role
</p>
</TD>
<TD>
</TD>
<TD>
<p>
X
</p>
</TD>
<TD>
<p>
[0..0]
</p>
</TD>
<TD>
<p>
15
</p>
</TD>
</TR>
<TR>
<TD>
<p>
}]
</p>
</TD>
<TD>
<p>
--- INSURANCE end
</p>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
</TR>
<TR>
<TD>
<p>
[  ACC  ]
</p>
</TD>
<TD>
<p>
Accident Information 
</p>
</TD>
<TD>
</TD>
<TD>
<p>
X
</p>
</TD>
<TD>
<p>
[0..0]
</p>
</TD>
<TD>
<p>
6
</p>
</TD>
</TR>
<TR>
<TD>
<p>
[  UB1  ]
</p>
</TD>
<TD>
<p>
Universal Bill Information
</p>
</TD>
<TD>
</TD>
<TD>
<p>
X
</p>
</TD>
<TD>
<p>
[0..0]
</p>
</TD>
<TD>
<p>
6
</p>
</TD>
</TR>
<TR>
<TD>
<p>
[  UB2  ]
</p>
</TD>
<TD>
<p>
Universal Bill 92 Information
</p>
</TD>
<TD>
</TD>
<TD>
<p>
X
</p>
</TD>
<TD>
<p>
[0..0]
</p>
</TD>
<TD>
<p>
6
</p>
</TD>
</TR>
<TR>
<TD>
<p>
[  PDA  ]
</p>
</TD>
<TD>
<p>
Patient Death and Autopsy
</p>
</TD>
<TD>
</TD>
<TD>
<p>
X
</p>
</TD>
<TD>
<p>
[0..0]
</p>
</TD>
<TD>
<p>
3
</p>
</TD>
</TR>
</TABLE>
<A ID="Heading889" >
<H3>
2B.9.1 Segment definitions
</H3>
<p>
The set of segments and segment groups included within the message shall be defined. Any segments or segment groups that are required by HL7 shall be included.
</p>
<A ID="Heading890" >
<H3>
2B.9.2 Segment usage 
</H3>
<p>
The usage of the segment or group within a message shall be defined using one of the codes in the previously defined usage table.
</p>
<A ID="Heading891" >
<H3>
2B.9.3 Segment cardinality
</H3>
<p>
Some segments and segment groups within the HL7 message are allowed to repeat. The cardinality of all the segments and groups within the message shall be defined.
</p>
<p>
Static definition - segment level 
</p>
<p>
The segment level static definition shall be documented using the HL7 segment attribute table format with the addition of specifying length, usage and cardinality for each of the fields contained within the segment.
</p>
<p>
The length column shall be updated to accurately reflect the maximum allowed length for the field within this segment definition.
</p>
<p>
The usage column shall accurately reflect the usage of the field within this segment definition.
</p>
<p>
The cardinality column shall accurately reflect the minimum and maximum number of repetitions of the field allowed for this segment definition.
</p>
<p>
Sample Segment Level Definition  PID (Patient Identification) Segment
</p>
<TABLE>
<TR>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
</TR>
<TR>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
</TR>
<TR>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
</TR>
<TR>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
</TR>
<TR>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
</TR>
<TR>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
</TR>
<TR>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
</TR>
<TR>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
</TR>
<TR>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
</TR>
<TR>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
</TR>
<TR>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
</TR>
<TR>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
</TR>
<TR>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
</TR>
<TR>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
</TR>
<TR>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
</TR>
<TR>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
</TR>
<TR>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
</TR>
<TR>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
</TR>
<TR>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
</TR>
<TR>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
</TR>
<TR>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
</TR>
<TR>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
</TR>
<TR>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
</TR>
<TR>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
</TR>
<TR>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
</TR>
<TR>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
</TR>
<TR>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
</TR>
<TR>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
</TR>
<TR>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
</TR>
<TR>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
</TR>
<TR>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
</TR>
<TR>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
</TR>
<TR>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
</TR>
<TR>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
</TR>
<TR>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
</TR>
<TR>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
</TR>
<TR>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
</TR>
<TR>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
</TR>
<TR>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
</TR>
<TR>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
</TR>
<TR>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
</TR>
</TABLE>
<A ID="Heading892" >
<H3>
2B.9.4 Field definitions
</H3>
<p>
The set of fields of each segment within the message level definition shall be specified.
</p>
<p>
If a segment occurs multiple times within a message profile, it may be represented by different segment profiles. This shall be explicitly defined within the message level definition.
</p>
<A ID="Heading893" >
<H3>
2B.9.5 Field cardinality
</H3>
<p>
Some fields within a segment are allowed to repeat. The cardinality of all the fields within the segment shall be defined.
</p>
<A ID="Heading894" >
<H3>
2B.9.6 Field usage 
</H3>
<p>
The usage of the field within a segment shall be defined consistent with the profile type, and using one of codes identified in the previously defined Usage tables.
</p>
<A ID="Heading895" >
<H3>
2B.9.7 Data type
</H3>
<p>
The data type of the field within a segment shall be updated to accurately reflect the data type for the field within this segment definition.
</p>
<A ID="Heading896" >
<H3>
2B.9.8 Length
</H3>
<p>
The length of the field within a segment shall be updated to accurately reflect the correct length for the field within this segment definition. Here two information items shall be provided representing the required minimum length a data constituent must have and the maximum length this constituent must not exceed.
</p>
<A ID="Heading897" >
<H3>
2B.9.9 Conformance Length
</H3>
<p>
This length represents the number of characters that a conformant application must be able to handle. For further information please see Chapter 2, section 2.5.5.3, "Conformance Length".
</p>
<A ID="Heading898" >
<H3>
2B.9.10 Table reference
</H3>
<p>
The name of the table of the field within a segment shall be updated to accurately reflect the table used for the field within this segment definition.
</p>
<A ID="Heading899" >
<H2>
2B.10 Static definition - field level  
</H2>
<A ID="Heading900" >
<H3>
2B.10.1 Field Definitions
</H3>
<p>
Each individual field within a segment shall be completely defined to eliminate any possible ambiguity.
</p>
<p>
In cases where HL7 2.x field descriptions are not sufficient, a precise semantic definition shall be specified.
</p>
<A ID="Heading901" >
<H3>
2B.10.2 User-defined and suggested field values
</H3>
<p>
The allowed code sets (table) for many fields within the HL7 Standard are specified as user-defined (data type IS) or HL7-defined (data type ID) values. 
</p>
<p>
In these cases, the exact allowed code set shall be specified. These values shall be defined according to the specified scope of use for the message profile by vendors, provider, or within a realm.
</p>
<p>
Coded Entry (CE, CF, CWE, and CNE) type fields are specified as being populated based on coding systems. For each of these fields, the specific coding system used shall be identified. Compliant applications are required to use the specified coding system, but may also use an alternate coding system as supported by the data type (See the example within each data type definition).
</p>
<A ID="Heading902" >
<H3>
2B.10.3 Constant values
</H3>
<p>
If an element will always have a constant value, this shall be specified. Constant values may only be specified for elements that represent primitive data types, i.e., they have no components or sub-components.
</p>
<A ID="Heading903" >
<H3>
2B.10.4 Data values
</H3>
<p>
A list of example data values for the element may be specified. Data values may only be specified for elements that represent primitive data types i.e. they no components or sub-components.
</p>
<A ID="Heading904" >
<H3>
2B.10.5 Pattern Matching
</H3>
<p>
Constraints for matching patterns within fields may be specified.  In addition to textual description of the constraint, formal expressions may be specified.  These formal expressions can be Object Constraint Language (OCL), regular expressions (RegEx), and XML Path Language (XPath) 
</p>
<A ID="Heading905" >
<H3>
2B.10.6 Element Relationships
</H3>
<p>
Element relationships may be may be specified.  In addition to textual description of these constraints, formal expressions may be specified.  These formal expressions can be Object Constraint Language (OCL), regular expressions (RegEx), and XML Path Language (XPath)
</p>
<A ID="Heading906" >
<H3>
2B.10.7 Profiling Multiple Occurrences
</H3>
<p>
Individual occurrences of an element can be profiled differently. This mechanism allows for greater flexibility for constraining elements. For example, each occurrence of a patient identifier list can be profiled differently. Prior to HL7 V2.8 individual occurrences of an element had to be profiled the same constraints and often represented a superset of the constraints.
</p>
<p>
To illustrate the utility of profiling individual elements, consider the following example:
</p>
<p>
Suppose a field has a cardinality of 3.  Suppose the field is made up of 4 components and that the first occurrence of the field should always be constrained as indicated:
</p>
<p>
&lt;comp name="comp 1" usage="R"/&gt;
</p>
<p>
&lt;comp name="comp 2" usage="R"/&gt;
</p>
<p>
&lt;comp name="comp 3" usage="X"/&gt;
</p>
<p>
&lt;comp name="comp 4" usage="X"/&gt;
</p>
<p>
Suppose the second occurrence of the field, when present, is constrained in the following way:
</p>
<p>
&lt;comp name="comp 1" usage="R"/&gt;
</p>
<p>
&lt;comp name="comp 2" usage="RE"/&gt;
</p>
<p>
&lt;comp name="comp 3" usage="RE"/&gt;
</p>
<p>
&lt;comp name="comp 4" usage="X"/&gt;
</p>
<p>
And that the third occurrence of the field is as follows:
</p>
<p>
&lt;comp name="comp 1" usage="X"/&gt;
</p>
<p>
&lt;comp name="comp 2" usage="X"/&gt;
</p>
<p>
&lt;comp name="comp 3" usage="R"/&gt;
</p>
<p>
&lt;comp name="comp 4" usage="R"/&gt;
</p>
<p>
Using the profiling mechanism prior v 2.8, it is not possible to constrain the field in the manner indicated.  To allow for the 3 occurrences described above, the profile would have to include an element such as the following for constraining the field:
</p>
<p>
&lt;field name="field X" min="1" max ="3" ...&gt;
</p>
<p>
&lt;comp name="comp 1" usage="RE"/&gt;
</p>
<p>
&lt;comp name="comp 2" usage="RE"/&gt;
</p>
<p>
&lt;comp name="comp 3" usage="RE"/&gt;
</p>
<p>
&lt;comp name="comp 4" usage="RE"/&gt;
</p>
<p>
&lt;/field&gt;
</p>
<p>
To allow the profile writer to constrain each occurrence of the field, an occurrence element can be used.  Using the occurrence element, the profile would replace the field definition above with the following field definition:
</p>
<p>
&lt;field name="field X" min="1" max ="3" ...&gt;
</p>
<p>
&lt;occurrence &gt;
</p>
<p>
&lt;comp name="comp 1" usage="R"/&gt;
</p>
<p>
&lt;comp name="comp 2" usage="R"/&gt;
</p>
<p>
&lt;comp name="comp 3" usage="X"/&gt;
</p>
<p>
&lt;comp name="comp 4" usage="X"/&gt;
</p>
<p>
&lt;/occurrence&gt;
</p>
<p>
&lt;occurrence&gt;
</p>
<p>
&lt;comp name="comp 1" usage="R"/&gt;
</p>
<p>
&lt;comp name="comp 2" usage="RE"/&gt;
</p>
<p>
&lt;comp name="comp 3" usage="RE"/&gt;
</p>
<p>
&lt;comp name="comp 4" usage="X"/&gt;
</p>
<p>
&lt;/occurrence&gt;
</p>
<p>
&lt;occurrence&gt;
</p>
<p>
&lt;comp name="comp 1" usage="X"/&gt;
</p>
<p>
&lt;comp name="comp 2" usage="X"/&gt;
</p>
<p>
&lt;comp name="comp 3" usage="R"/&gt;
</p>
<p>
&lt;comp name="comp 4" usage="R"/&gt;
</p>
<p>
&lt;/occurrence&gt;
</p>
<p>
&lt;/field&gt;
</p>
<p>
To be clear, it should be noted that the new profile element does not imply any changes to the message encoding; it simply allows for greater control over the individual occurrences of the element than the standard presently allows.
</p>
<p>
There are a number of options that can be used to specify individual occurrences. The order attribute can be specified to indicate if the order of the occurrences is significant.  By default, as in the example above if the order is not specified or specified as "false" then the instance elements can adhere to any of the occurrences specified. If the order attribute is "true" then order is significant and the instance elements must appear in the order specified. 
</p>
<p>
To enable specific occurrences to be constrained without the need to specify an order constraint for every occurrence of the element, the number attribute is optional.  The order and number attributes are mutually exclusive. As an example, if it was necessary to tightly constrain the second occurrence but more flexibility was allowed the other occurrences, the profile could specify:
</p>
<p>
&lt;field name="field X" min="1" max ="3" ...&gt;
</p>
<p>
&lt;occurrence&gt;
</p>
<p>
&lt;comp name="comp 1" usage="RE"/&gt;
</p>
<p>
&lt;comp name="comp 2" usage="RE"/&gt;
</p>
<p>
&lt;comp name="comp 3" usage="RE"/&gt;
</p>
<p>
&lt;comp name="comp 4" usage="RE"/&gt;
</p>
<p>
&lt;/occurrence&gt;
</p>
<p>
&lt;occurrence number="2"&gt;
</p>
<p>
&lt;comp name="comp 1" usage="R"/&gt;
</p>
<p>
&lt;comp name="comp 2" usage="R"/&gt;
</p>
<p>
&lt;comp name="comp 3" usage="X"/&gt;
</p>
<p>
&lt;comp name="comp 4" usage="X"/&gt;
</p>
<p>
&lt;/occurrence&gt;
</p>
<p>
&lt;/field&gt;
</p>
<p>
An occurrence element without a number attribute would be interpreted as applying to all occurrences of the element not otherwise specified.  In other words, in the above case, all components in each occurrence of the field are designated as RE except the second, which must have exactly the first two components present. Occurrence specifications can have any number of number or non-number attributes.
</p>
<p>
The occurrence element can also be specified based on the value of a designated component in the field. The "position" attribute specifies the component that is evaluated to determine the profiled occurrence.  The component that the position attribute references shall always be profiled as required. The "value" attribute provides the value for determining the profiled occurrence; it is evaluated with the component referenced by the position attribute. For example, the occurrences of field with an XPN data type can be profiled individually based on the name type code (component 7 in this case).
</p>
<p>
&lt;field name="field X" min="1" max ="3" position= "7"...&gt;
</p>
<p>
&lt;!legal name--&gt;
</p>
<p>
&lt;occurrence  value="L"&gt;
</p>
<p>
&lt;Component name="family name" usage="R"/&gt;
</p>
<p>
&lt;Component name="given name" usage="R"/&gt;
</p>
<p>
&lt;Component name="Initials" usage="X"/&gt;
</p>
<p>
&lt;Component name="Suffix" usage="X"/&gt;
</p>
<p>
&lt;Component name="Prefix" usage="R"/&gt;
</p>
<p>
&lt;Component name="Degree" usage="X"/&gt;
</p>
<p>
&lt;Component name="Name Type Code" usage="R"/&gt;
</p>
<p>
Etc.
</p>
<p>
&lt;/occurrence&gt;
</p>
<p>
&lt;!display name--&gt;
</p>
<p>
&lt;occurrence value="D"&gt;
</p>
<p>
&lt;Component name="family name" usage="R"/&gt;
</p>
<p>
&lt;Component name="given name" usage="R"/&gt;
</p>
<p>
&lt;Component name="Initials" usage="RE"/&gt;
</p>
<p>
&lt;Component name="Suffix" usage="RE"/&gt;
</p>
<p>
&lt;Component name="Prefix" usage="RE"/&gt;
</p>
<p>
&lt;Component name="Degree" usage=RE"/&gt;
</p>
<p>
&lt;Component name="Name Type Code" usage="R"/&gt;
</p>
<p>
Etc.
</p>
<p>
&lt;/occurrence&gt;
</p>
<p>
&lt;!birthname name--&gt;
</p>
<p>
&lt;occurrence value="B"&gt;
</p>
<p>
&lt;Component name="family name" usage="R"/&gt;
</p>
<p>
&lt;Component name="given name" usage="R"/&gt;
</p>
<p>
&lt;Component name="Initials" usage="RE"/&gt;
</p>
<p>
&lt;Component name="Suffix" usage="X"/&gt;
</p>
<p>
&lt;Component name="Prefix" usage="X"/&gt;
</p>
<p>
&lt;Component name="Degree" usage="X"/&gt;
</p>
<p>
&lt;Component name="Name Type Code" usage="R"/&gt;
</p>
<p>
Etc.
</p>
<p>
&lt;/occurrence&gt;
</p>
<p>
&lt;/field&gt;
</p>
<p>
If the name type code in the element occurrence is "L" then the occurrence specification is applied. The same logic is also applied to display and birthname occurrences. 
</p>
<p>
Not all occurrences need to have a value attribute when using the position/value occurrence profiling option. An occurrence element without a value attribute would be interpreted as applying to all occurrences of the element not otherwise specified. 
</p>
<p>
The position/value occurrence specifications cannot be specified with either order or number occurrence specifications. That is, the concepts cannot be combined.
</p>
<A ID="Heading907" >
<H3>
2B.10.8 Components and subcomponents
</H3>
<p>
Many fields and components in versions of HL7 prior to v 2.5 were defined to be Composite Data (CM) data types. As of 2.5, all field instances will reference a valid data type other than CM. Addenda for versions 2.3.1 and 2.4 are available that define more precise names for the CM data types. These names allow a more precise data type name for each of the fields using the former CM data type to be more easily used for XML encoding of message instances. Although message profiling is not limited to a specific version of HL7, it is strongly encouraged that these new data types be used to increase interoperability between versions.
</p>
<p>
Each component within composite fields shall be profiled. This requires defining the usage, length, data type, and data values of each of the components. Where there are sub-components of a component, each of the sub-components shall also be profiled using the same method. With the exception of cardinality, the rules for these definitions follow those for fields (See section 2.B.9, "Static definition - field level").
</p>
<A ID="Heading908" >
<H2>
2B.11 Message profile document  
</H2>
<p>
HL7 Headquarters will provide a utility, hereafter called registry, on the Members'' Only Web site (http://www.hl7.org) where the message profile can be registered.
</p>
<p>
Messages profiles in the registry are all catalogued with a set of metadata. Those entities submitting message profiles into the registry will need to fill out a form that captures the required metadata information. The registry and the metadata will be documented in an informative document and will not be discussed further in this document.
</p>
<A ID="Heading909" >
<H3>
2B.11.1 Message profile document format
</H3>
<p>
The Conformance and Guidance for Implementation and Testing  (CGIT)  Work Group researched the best approach to standardize the format of a message profile to facilitate comparison and measurement. XML (eXtensible Markup Language XML W3C XML 1.0 2nd Ed) documents appeared to be the best tool for this.
</p>
<p>
This use of XML is not, in any way, related to the HL7 2.xml encoding specification that describes the XML encoding of message instances. The message profile document format provides structure to the documentation of the message profile and does not limit the encoding of an actual message instance.
</p>
<A ID="Heading910" >
<H3>
2B.11.2 Message profile document definition
</H3>
<p>
A message profile document will be a valid HL7 message profiles if it conforms to the constraints expressed in the message profile document definition (See section 2.B.13. "Conformity Assessment of Usage Codes"), and the additional rules described in this document.
</p>
<A ID="Heading911" >
<H2>
2B.12 Documentation
</H2>
<A ID="Heading912" >
<H3>
2B.12.1 Documentation Hierarchy
</H3>
<p>
The standard provides the foundation for implementation development. The standard includes many options which allows for multiple interpretations and implementations that exhibit differing behavior dependent on the options supported by the implementation. Given the possibilities for variations in implementation behavior, it is essential that vendors claim conformance to the standard with a clear identification of the optional behavior supported.
</p>
<p>
To emphasize the importance of the above claim and its relationship to the standard the concept of a "documentation hierarchy" is introduced.
</p>
<A ID="Heading913" >
<H3>
2B.12.2 Introduction
</H3>
<p>
According to IEEE (glossary 1990) the term "semantic interoperability" is "the ability of two or more systems or components to exchange information and to use the information that has been exchanged". The first condition requires that the system is capability of importing information from another system or to export information to another system. Generally testing that systems satisifes this condition is difficult to ascertain and can only be achieved using the actual system that provides or consumes the data. Good documentation though, may serve to ameliorate the problem. One has to be aware, that good documentation is an essential part of all interfaces and that (semantic) interoperability cannot be achieved without sufficient documentation.
</p>
<A ID="Heading914" >
<H3>
2B.12.3 Problem Space
</H3>
<p>
As mentioned previously, testing outside an environment in which applications are deployed is not practical; otherwise tests are based on assumptions which may not be valid. For example, the configuration, the master files, or the software components in use may differ. Users, (e.g., hospitals) may prefer to make preliminary assessments of an application''s interoperability capabilities before committing to purchase. To achieve this goal without investing too many resources, vendors and user need to have different choices available to them.
</p>
<A ID="Heading915" >
<H3>
2B.12.4 Hierarchy of Profiles
</H3>
<p>
First, it is useful to recognize that the standard is a profile and profiles that are derived from it introduce a hierarchy of profiles:
</p>
<img src="ch02b_7.png" />
<p>
Following this hierarchy, profiles can be used by different authorities as explained in the follow illustration:
</p>
<img src="ch02b_8.png" />
<p>
As shown, there are different options for how profiles can be used. 
</p>
<p>
Note 1: The hierarchy of constrainable profiles may contain more than two levels/recursions.
</p>
<p>
Note 2: IHE offers constrainable profiles which are domain specific. They are also based on national addenda like realm-specific Z-segments. From that perspective they form a two level hierarchy alone.
</p>
<A ID="Heading916" >
<H3>
2B.12.5 Architecture
</H3>
<p>
Therefore, in almost all situations the following component architecture applies. Unfortunately, some of the architectural components are not yet in existence and can therefore be regarded as "virtual". Nevertheless, creating them is straightforward.
</p>
<img src="ch02b_9.png" />
<p>
Note: Although the relationship shown are for implementation profiles (arrow 6), it equally applies to constrainable profiles.
</p>
<A ID="Heading917" >
<H3>
2B.12.6 Components
</H3>
<p>
The boxes in the diagram above represent the following components:
</p>
<TABLE border=1>
<TR>
<TD>
</TD>
<TD>
<p>
Documentation
</p>
</TD>
<TD>
<p>
Implementation
</p>
</TD>
</TR>
<TR>
<TD>
<p>
Components
</p>
</TD>
<TD>
<p>
Constrainable Profile
</p>
</TD>
<TD>
<p>
Implementable Profile
</p>
</TD>
<TD>
</TD>
</TR>
<TR>
<TD>
<p>
A
</p>
</TD>
<TD>
<p>
X
</p>
</TD>
<TD>
</TD>
<TD>
</TD>
</TR>
<TR>
<TD>
<p>
B
</p>
</TD>
<TD>
<p>
X
</p>
</TD>
<TD>
</TD>
<TD>
</TD>
</TR>
<TR>
<TD>
<p>
C
</p>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
<p>
X
</p>
</TD>
</TR>
<TR>
<TD>
<p>
D
</p>
</TD>
<TD>
</TD>
<TD>
<p>
X
</p>
</TD>
<TD>
</TD>
</TR>
<TR>
<TD>
<p>
E
</p>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
<p>
X
</p>
</TD>
</TR>
<TR>
<TD>
<p>
F
</p>
</TD>
<TD>
</TD>
<TD>
<p>
X
</p>
</TD>
<TD>
</TD>
</TR>
</TABLE>
<p>
The standard and an implementation guide based on this standard both represent a constrainable profile, i.e., they provide a set of requirements and constraints, and both still contain optionality. An implementation guide should introduce additional constraints.
</p>
<p>
An implementation guide can either be universal (e.g., published by PEOs like IHE), realm specific (e.g., C32 from HIPSP), or site-specific (hospital chain like Kaiser Permanente in the USA or Rh?n in Germany).
</p>
<p>
A vendoreither 1 or 2 in the diagram aboveis providing an implementation (C or E) based on that guidance. Usually, these products are accompanied by appropriate documentation (D or F). Based on this notion, these documents should fulfil the requirements for implementation profiles defined in this chapter.
</p>
<A ID="Heading918" >
<H3>
2B.12.7 Relationships
</H3>
<p>
Hence, a relationship among those components exists. For the purpose of testing semantic interoperability, the following are of importance:
</p>
<TABLE border=1>
<TR>
<TD>
Arrow</TD>
<TD>
Linkage</TD>
<TD>
Conformance</TD>
<TD>
Compliance</TD>
<TD>
Compatibility</TD>
<TD>
</TD>
</TR>
<TR>
<TD>
0</TD>
<TD>A - B
</TD>
<TD>
</TD>
<TD>x
</TD>
<TD>
</TD>
<TD>
</TD>
</TR>
<TR>
<TD>
1</TD>
<TD>B - C
</TD>
<TD>x
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>&lt;==+
</TD>
</TR>
<TR>
<TD>
2</TD>
<TD>B - D
</TD>
<TD>
</TD>
<TD>x
</TD>
<TD>
</TD>
<TD>&lt;==|==+
</TD>
</TR>
<TR>
<TD>
3</TD>
<TD>B - E
</TD>
<TD>x
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>&lt;==+  |
</TD>
</TR>
<TR>
<TD>
4</TD>
<TD>B - F
</TD>
<TD>
</TD>
<TD>x
</TD>
<TD>
</TD>
<TD>&lt;=====+
</TD>
</TR>
<TR>
<TD>
5</TD>
<TD>C - E
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>x
</TD>
<TD>
</TD>
</TR>
<TR>
<TD>
6</TD>
<TD>D - F
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>x
</TD>
<TD>
</TD>
</TR>
<TR>
<TD>
7</TD>
<TD>C - D
</TD>
<TD>x
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
</TR>
<TR>
<TD>
8</TD>
<TD>E - F
</TD>
<TD>x
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
</TR>
</TABLE>
<p>
If two documents or profiles are evaluated for consistency we describe them as compliant (0, 2, and 4). If an implementation is tested against some guidance it is called conformant (1, 3, 7, and 8). These two evaluations are conducted on different levels. If a test is done on the same level against the same type (either documents/profiles or implementation) it is called compatibility (5 and 6).
</p>
<A ID="Heading919" >
<H3>
2B.12.8 Testing Types
</H3>
<p>
The profile architecture diagram above dictates the necessity for different types of testing. The table below provides details of the testing types:
</p>
<TABLE border=1>
<TR>
<TD>
<p>
Testing Type
</p>
</TD>
<TD>
<p>
Direction
</p>
</TD>
<TD>
<p>
Test Artifact
</p>
</TD>
<TD>
<p>
Description
</p>
</TD>
</TR>
<TR>
<TD>
<p>
Profile Compliance
</p>
</TD>
<TD>
<p>
Vertical
</p>
</TD>
<TD>
<p>
Profiles
</p>
</TD>
<TD>
<p>
Profiles are tested against each other to determine whether one is a constraint of (i.e., consistent with) the other. Profile compliance testing is appropriate when additional constraints are specified to successive profiles in the hierarchy (e.g., standard to a constrainable profile to an implementation profile).
</p>
</TD>
</TR>
<TR>
<TD>
<p>
Application Conformance
</p>
</TD>
<TD>
<p>
Vertical
</p>
</TD>
<TD>
<p>
Application
</p>
</TD>
<TD>
<p>
Provides an assessment of how well the application fulfils the requirements specified in a profile. This is conformance testing.
</p>
</TD>
</TR>
<TR>
<TD>
<p>
Profile Compatibility
</p>
</TD>
<TD>
<p>
Horizontal
</p>
</TD>
<TD>
<p>
Profiles
</p>
</TD>
<TD>
<p>
Profiles are tested against each other to determine whether the pair can be used by applications to successfully exchange information (interoperate). If a profile pair that constrains the same underlying profile conflict with each other chances of interoperability of applications that implement these profiles are diminished.
</p>
</TD>
</TR>
<TR>
<TD>
<p>
Application Interoperability
</p>
</TD>
<TD>
<p>
Horizontal
</p>
</TD>
<TD>
<p>
Applications
</p>
</TD>
<TD>
<p>
Applications are tested with each other to determine whether they can successfully exchange information (interoperate). Applications that implement the same profile or compatible profiles and have successfully passed conformance tests will increase the likelihood of interoperating. IHE connectathons are an example of interoperability testing.
</p>
</TD>
</TR>
</TABLE>
<A ID="Heading920" >
<H3>
2B.12.9 Documentation Quality
</H3>
<p>
The table given below indicates the level of documentation quality for an implemented interface.
</p>
<TABLE border=1>
<TR>
<TD>
<p>
Documentation Quality
</p>
</TD>
<TD>
<p>
Description
</p>
</TD>
<TD>
<p>
Consequences
</p>
</TD>
</TR>
<TR>
<TD>
<p>
0  Undocumented Unsubstantiated Claim
</p>
</TD>
<TD>
<p>
A vendor (or more generically, a document provider) claims conformance to HL7; however the claim is unsubstantiated.
</p>
<p>
Note: This level can be treated as the "standard conformance" as all vendors claim conformance to HL7 per se.
</p>
</TD>
<TD>
<p>
None
</p>
</TD>
</TR>
<TR>
<TD>
<p>
1  Documented Unsubstantiated Claim
</p>
</TD>
<TD>
<p>
A vendor provides evidence of a claim with documentation of the interface. The documentation can be in any format (e.g., a text document) and the contents of the claim are not substantiated.
</p>
<p>
Note: For example, a vendor may copy paragraphs from the original standard; this is an acceptable practice at this level of documentation quality.
</p>
</TD>
<TD>
<p>
Vendor must provide a document.
</p>
</TD>
</TR>
<TR>
<TD>
<p>
2  Documented Standard Unsubstantiated Claim
</p>
</TD>
<TD>
<p>
The documentation provided fulfils the requirements of a conformance profile as listed in HL7 V2 chapter 2B.
</p>
</TD>
<TD>
<p>
Vendor must provide a conformance statement.
</p>
</TD>
</TR>
<TR>
<TD>
<p>
3  Documented Standard Machine Processable Unsubstantiated Claim
</p>
</TD>
<TD>
<p>
The documentation is machine processable.
</p>
<p>
Note: One option is to use a tool (e.g., the MWB) to create this file.
</p>
</TD>
<TD>
<p>
The user or vendor has to provide a computable (constrainable) conformance profile file.
</p>
</TD>
</TR>
<TR>
<TD>
<p>
4 - Documented Standard (Implementation Profile Level) Machine Processable Unsubstantiated Claim
</p>
</TD>
<TD>
<p>
The documentation is a conformance profile fulfilling the criteria for implementable profiles, i.e. no options are allowed any more.
</p>
<p>
Note: the criteria listed for level 3 allows a test to verify that the profile fulfils the requirements for implementable profiles.
</p>
</TD>
<TD>
<p>
Vendor must provide a file which fulfils the requirements for implementable conformance profile.
</p>
</TD>
</TR>
<TR>
<TD>
<p>
5 - Documented Standard Substantiated Claim
</p>
</TD>
<TD>
<p>
The profile is (successfully) tested against another profile.
</p>
<p>
Note: This testing is done against a higher level (=less constraint) profile, probably a constrainable profile issued either by a vendor, affiliate or HQ itself. Therefore, this testing is done vertically and checks whether the provided profile only add additional constraints.
</p>
</TD>
<TD>
<p>
Requires references to the profiles tested against. Furthermore, the results of the tests must be stated.
</p>
<p>
Furthermore, the means and details of this testing must be specified.
</p>
<p>
As a consequence, it will become obvious, whether the relationship to the underlying profile is "conformant" or "conflicting".
</p>
</TD>
</TR>
<TR>
<TD>
<p>
6 - Documented Standard Compatibility Substantiated Claim
</p>
</TD>
<TD>
<p>
Another option of testing is horizontally. This way, two (constrainable or implementable) profiles are tested with a sender/receiver perspective. One profile takes the role of the sender, the other of the receiver. It should be tested, whether this will result in interoperability problems. During the testing, the (machine processable) representations of the profiles are compared with each other.
</p>
<p>
Note: On this level we talk about "compatible" and "incompatible" profiles.
</p>
</TD>
<TD>
<p>
Requires references to the profiles tested against. Furthermore, the role must be mentioned.
</p>
</TD>
</TR>
</TABLE>
<A ID="Heading921" >
<H3>
2B.12.10 Impacts
</H3>
<p>
A significant advantage of this concept is that it has no impact on implementations because it only addresses documentation. The documentation gives an indication of how close a vendor''s implementation is conformant to HL7 V2 requirements. The use of tools for creating such documentation becomes necessary at level 3. Furthermore, at the higher levels the documentation should provide a section listing the profiles; this will enable verification. It is recommended that both the documentation and profile be publicly availablepreferably on the vendor''s website. Following the documentation recommendations presented in this chapter will better inform consumers of vendor''s products. 
</p>
<A ID="Heading922" >
<H3>
2B.12.11 Primary Focus of Requirement
</H3>
<p>
It is recognized that for complex messages satisfying the highest level is challenging. As indicated above, testing profiles using operational implementations is sufficient for satisfying this requirement. A prerequisite is that the documentation reflects the interface behavior. Such verification is only enforceable if such documentation is part of the agreements.
</p>
<p>
It should be noted that we have discussed vendor claims through documentation; this is only a claim of what they implemented. It is not an indication that the vendor''s interface implementation is conformant.
</p>
<p>
It is also recognized that we are making the assumption that the documented profile has been implemented as an interface. When a user buys an interface they should insist that the documentation be included into the agreement. This ensures that sufficient documentation of the interface functionality of the implementation exists. Such documentation and agreements enable testing. Several tools are available to test messages/interfaces against message profile.
</p>
<A ID="Heading923" >
<H3>
2B.12.12 Advantages for Implementers
</H3>
<p>
It is advantageous to test interfaces thoroughly; providing good documentation on the capabilities of the interface facilitates testing and ultimately expedites installation of the interface. A testable profile provides an effective way to check for compatibility problems in advance. Currently, many problems are undetected at installation and are discovered by the customer during use. Specific issues like the maximum length of data elements are generally not tested. Inclusion of robust documentation as described here will shift efforts from accidental testing and support difficulties to automated testing with will increase the likelihood of interoperability.
</p>
<A ID="Heading924" >
<H2>
2B.13 Tools  
</H2>
<p>
The tools used for creation, sharing, re-use, reporting, analyzing, and comparing message profiles are outside the scope of the HL7 standard. Refer to the Conformance and Guidance for Implementation and Testing (CGIT) Work Group web site for useful links that are of widespread interest to, and in support of, message profiles and the (CGIT) Work Group.
</p>
<A ID="Heading925" >
<H2>
2B.14 Conformity Assessment of Usage Codes
</H2>
<A ID="Heading926" >
<H3>
2B.14.1 Conformity Assessment of Usage Codes
</H3>
<p>
The preceding sections describe conformance constructs used in message profiles. This section seeks to clarify the meaning of the conformance usage codes by providing a context in which the requirements can be assessed. That is, a conformity assessment value is given for each conformance construct while considering the possible states of data presence and conditional outcomes (if applicable). The result is a set of truth tables that will aid readers interpret the meaning of the conformance constructs. Where applicable the assessment is given for the sending and receiving perspective. The information provided in this section can also serve as a guide when conducting conformance testing.
</p>
<A ID="Heading927" >
<H3>
2B.14.2 Usage  Sending Application
</H3>
<p>
This section presents the truth tables for assessing usage code for receiving applications. The following provides an explanation of the heading columns.
</p>
<p>
Usage Indicator  Usage declared in the conformance profile for the element.
</p>
<p>
Test Data Provided  Indicates whether or not data was provided for this element in the test data set.
</p>
<p>
Conformity Assessment Indicator  Indicates the valid action the sender should take when populating the message element.
</p>
<p>
Actual Data Sent  Indicates the possible behavior, i.e., whether or not the sender populate the element with a value
</p>
<p>
Conformity Assessment  Indicates the result of the conformity assessment.
</p>
<p>
Comments  Provides additional insight of the evaluation scenario.
</p>
<p>
As an example the first entry in the first table can be interpreted as: The sender profile specified the element usage as required (R). Data is available to the sender; therefore the requirement for the sender is to populated the element (i.e., the element shall be present in the message). If the data is present for the element then the application is conformant with respect to the element usage. If the data is not-present for the element then the application is not conformant with respect to usage of the element.
</p>
<p>
Conformity Assessment of the Required Usage Code for Sending Applications
</p>
<TABLE border=1>
<TR>
<TD>
<p>
Usage Indicator
</p>
</TD>
<TD>
<p>
Test Data Provided
</p>
</TD>
<TD>
<p>
Conformity Assessment Indicator
</p>
</TD>
<TD>
<p>
Actual Data Sent
</p>
</TD>
<TD>
<p>
Conformity Assessment
</p>
</TD>
<TD>
<p>
Comments
</p>
</TD>
</TR>
<TR>
<TD>
<p>
R
</p>
</TD>
<TD>
<p>
Valued
</p>
</TD>
<TD>
<p>
Present
</p>
</TD>
<TD>
<p>
Present
</p>
</TD>
<TD>
<p>
Conformant
</p>
</TD>
<TD>
<p>
Affirmative test result
</p>
</TD>
</TR>
<TR>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
<p>
Not-Present
</p>
</TD>
<TD>
<p>
Non-Conformant
</p>
</TD>
<TD>
<p>
Application does not send the required element when a value is provided. 
</p>
</TD>
</TR>
<TR>
<TD>
<p>
R
</p>
</TD>
<TD>
<p>
Not-Valued
</p>
</TD>
<TD>
<p>
Noneexpected behavior is that no message is sent
</p>
</TD>
<TD>
<p>
Present
</p>
</TD>
<TD>
<p>
Non-Conformant
</p>
</TD>
<TD>
<p>
Application sends a value even though they do not have a valid value to send. 
</p>
</TD>
</TR>
<TR>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
<p>
Not-Present
</p>
</TD>
<TD>
<p>
Non-Conformant
</p>
</TD>
<TD>
<p>
Application sends a message with a required element not populated. 
</p>
</TD>
</TR>
<TR>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
<p>
No message sent
</p>
</TD>
<TD>
<p>
Conformant
</p>
</TD>
<TD>
<p>
Application correctly detects that they don''t have data for a required value and doesn''t send the message.
</p>
</TD>
</TR>
</TABLE>
<p>
Conformity Assessment of the Required but may be Empty Usage Code for Sending Applications
</p>
<TABLE border=1>
<TR>
<TD>
<p>
Usage Indicator
</p>
</TD>
<TD>
<p>
Test Data Provided
</p>
</TD>
<TD>
<p>
Conformity Assessment Indicator
</p>
</TD>
<TD>
<p>
Actual Data Sent
</p>
</TD>
<TD>
<p>
Conformity Assessment
</p>
</TD>
<TD>
<p>
Comments
</p>
</TD>
</TR>
<TR>
<TD>
<p>
RE
</p>
</TD>
<TD>
<p>
Valued
</p>
</TD>
<TD>
<p>
Present
</p>
</TD>
<TD>
<p>
Present
</p>
</TD>
<TD>
<p>
Conformant
</p>
</TD>
<TD>
<p>
Affirmative test result
</p>
</TD>
</TR>
<TR>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
<p>
Not-Present
</p>
</TD>
<TD>
<p>
Non-Conformant
</p>
</TD>
<TD>
<p>
Application does not send the required element when a value is provided. 
</p>
</TD>
</TR>
<TR>
<TD>
<p>
RE
</p>
</TD>
<TD>
<p>
Not-Valued
</p>
</TD>
<TD>
<p>
Not-Present
</p>
</TD>
<TD>
<p>
Present
</p>
</TD>
<TD>
<p>
Non-Conformant
</p>
</TD>
<TD>
<p>
Application sends a value even though they do not have a valid value to send. 
</p>
</TD>
</TR>
<TR>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
<p>
Not-Present
</p>
</TD>
<TD>
<p>
Conformant
</p>
</TD>
<TD>
<p>
Application sends a message without the element populated. Affirmative test result. 
</p>
</TD>
</TR>
</TABLE>
<p>
Conformity Assessment of Not-Supported Usage Code for Sending Applications
</p>
<TABLE border=1>
<TR>
<TD>
<p>
Usage Indicator
</p>
</TD>
<TD>
<p>
Test Data Provided
</p>
</TD>
<TD>
<p>
Conformity Assessment Indicator
</p>
</TD>
<TD>
<p>
Actual Data Sent
</p>
</TD>
<TD>
<p>
Conformity Assessment
</p>
</TD>
<TD>
<p>
Comments
</p>
</TD>
</TR>
<TR>
<TD>
<p>
X
</p>
</TD>
<TD>
<p>
Valued
</p>
</TD>
<TD>
<p>
Not-Present
</p>
</TD>
<TD>
<p>
Present
</p>
</TD>
<TD>
<p>
Non-Conformant
</p>
</TD>
<TD>
<p>
Non-conformant because value was sent for a not-supported element. 
</p>
</TD>
</TR>
<TR>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
<p>
Not-Present
</p>
</TD>
<TD>
<p>
Conformant
</p>
</TD>
<TD>
<p>
Test case results confirm correct usage of X element by providing data and the application did not send value.
</p>
</TD>
</TR>
<TR>
<TD>
<p>
X
</p>
</TD>
<TD>
<p>
Not-Valued
</p>
</TD>
<TD>
<p>
Not-Present
</p>
</TD>
<TD>
<p>
Present
</p>
</TD>
<TD>
<p>
Non-Conformant
</p>
</TD>
<TD>
<p>
Non-conformant because value was sent for a not-supported element.
</p>
</TD>
</TR>
<TR>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
<p>
Not-Present
</p>
</TD>
<TD>
<p>
Conformant
</p>
</TD>
<TD>
<p>
Confirms expected behavior. 
</p>
</TD>
</TR>
</TABLE>
<A ID="Heading928" >
<H4>
2B.14.2.0 Conditional (C(a/b)) Usage Conformity Assessment
</H4>
<p>
Conformance assessment for elements with conditional usage (i.e., C(a/b)) is dependent on the result of the condition predicate. For example, if conditional usage for an element is specified as C(R/X) and the result of the condition evaluation is true then the usage for the element is R and the conformity assessment table for R-required applies. Likewise, when the result of the condition evaluation is false then the usage for the element is X and the conformity assessment table for X-not supported applies.
</p>
<p>
When testing elements with conditional usage both the true and false scenarios need to be examined. The conformity assessment table below shows an example for the case C(R/X) for a sending application. Note that when the condition evaluates to true the assessment is the same as the R-required assessment table and when the condition evaluates to false the assessment is the same as the X-not supported. Similar tables can be built for the other combination such as C(R/RE), C(RE/X), etc.
</p>
<p>
Example Conformity Assessment of Conditional Usage Code C (R/X) for Sending Applications
</p>
<TABLE border=1>
<TR>
<TD>
<p>
Usage Indicator
</p>
</TD>
<TD>
<p>
Test Data Provided
</p>
</TD>
<TD>
<p>
Condition Predicate Result
</p>
</TD>
<TD>
<p>
Conformity Assessment Indicator
</p>
</TD>
<TD>
<p>
Actual Data Sent
</p>
</TD>
<TD>
<p>
Conformity Assessment
</p>
</TD>
<TD>
<p>
Comments
</p>
</TD>
</TR>
<TR>
<TD>
<p>
C(R/X)
</p>
</TD>
<TD>
<p>
Valued
</p>
</TD>
<TD>
<p>
True
</p>
</TD>
<TD>
<p>
Present
</p>
</TD>
<TD>
<p>
Present
</p>
</TD>
<TD>
<p>
Conformant
</p>
</TD>
<TD>
<p>
Affirmative test result
</p>
</TD>
</TR>
<TR>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
<p>
Not-Present
</p>
</TD>
<TD>
<p>
Non-Conformant
</p>
</TD>
<TD>
<p>
Application does not send the required element when a value is provided. 
</p>
</TD>
</TR>
<TR>
<TD>
<p>
C(R/X)
</p>
</TD>
<TD>
<p>
Not-Valued
</p>
</TD>
<TD>
<p>
True
</p>
</TD>
<TD>
<p>
Noneexpected behavior is that no message is sent.
</p>
</TD>
<TD>
<p>
Present
</p>
</TD>
<TD>
<p>
Non-Conformant
</p>
</TD>
<TD>
<p>
Application sends a value even though they do not have a valid value to send. 
</p>
</TD>
</TR>
<TR>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
<p>
Not-Present
</p>
</TD>
<TD>
<p>
Non-Conformant
</p>
</TD>
<TD>
<p>
Application sends a message with a required element not populated. 
</p>
</TD>
</TR>
<TR>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
<p>
No Message Sent
</p>
</TD>
<TD>
<p>
Conformant
</p>
</TD>
<TD>
<p>
Application correctly detects that they don''t have data for a required value and doesn''t send the message.
</p>
</TD>
</TR>
<TR>
<TD>
<p>
C(R/X)
</p>
</TD>
<TD>
<p>
Valued
</p>
</TD>
<TD>
<p>
False
</p>
</TD>
<TD>
<p>
Not-Present
</p>
</TD>
<TD>
<p>
Present
</p>
</TD>
<TD>
<p>
Non-Conformant
</p>
</TD>
<TD>
<p>
Non-conformant because value was sent for a not-supported element. 
</p>
</TD>
</TR>
<TR>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
<p>
Not-Present
</p>
</TD>
<TD>
<p>
Conformant
</p>
</TD>
<TD>
<p>
Test case results confirm correct usage of X element by providing data and the application did not send value.
</p>
</TD>
</TR>
<TR>
<TD>
<p>
C(R/X)
</p>
</TD>
<TD>
<p>
Not-Valued
</p>
</TD>
<TD>
<p>
False
</p>
</TD>
<TD>
<p>
Not-Present
</p>
</TD>
<TD>
<p>
Present
</p>
</TD>
<TD>
<p>
Non-Conformant
</p>
</TD>
<TD>
<p>
Non-conformant because value was sent for a not-supported element.  Value sent when condition is false and no value provided.
</p>
</TD>
</TR>
<TR>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
<p>
Not-Present
</p>
</TD>
<TD>
<p>
Conformant
</p>
</TD>
<TD>
<p>
Confirms expected behavior. 
</p>
</TD>
</TR>
</TABLE>
<A ID="Heading929" >
<H4>
2B.14.2.1 Optional (O) Usage Conformance Implications
</H4>
<p>
The usage indicator "O-Optional" must be further constrained to another value in order to allow for a conformity assessment. Therefore, no truth table is provided. 
</p>
<A ID="Heading930" >
<H3>
2B.14.3 Usage  Receiving Application
</H3>
<p>
This section presents the truth tables for assessing usage code for receiving applications. Below provides an explanation of the heading columns.
</p>
<p>
Usage Indicator  Usage declared in the conformance profile for the element.
</p>
<p>
Test Data Sent  Indicates whether or not the element was populated in the test message.
</p>
<p>
Conformity Assessment Indicator  Indicates how the receiver should respond to the test message with regards to an element.
</p>
<p>
Receiver Action  Indicates what action the receiver took in response to the test message.
</p>
<p>
Conformity Assessment  Indicates the result of the conformity assessment.
</p>
<p>
Comments  Provides additional insight of the evaluation scenario.
</p>
<p>
As an example, the first row in the first table can be interpreted as: The receiver profile has specified an element usage as required (R). A test message is created in which the element is populated with a value. The requirement for the receiver is to process the element. If the receiver processed the element then the application is conformant with respect to the element usage. If the application did not process the element then the application is not conformant with respect to the element usage.
</p>
<p>
Conformity Assessment of the Required Usage Code for Receiving Applications
</p>
<TABLE border=1>
<TR>
<TD>
<p>
Usage Indicator
</p>
</TD>
<TD>
<p>
Test Data Sent
</p>
</TD>
<TD>
<p>
Conformity Assessment Indicator
</p>
</TD>
<TD>
<p>
Receiver Action
</p>
</TD>
<TD>
<p>
Conformity Assessment
</p>
</TD>
<TD>
<p>
Comments
</p>
</TD>
</TR>
<TR>
<TD>
<p>
R
</p>
</TD>
<TD>
<p>
Valued
</p>
</TD>
<TD>
<p>
Process Element
</p>
</TD>
<TD>
<p>
Processed
</p>
</TD>
<TD>
<p>
Conformant
</p>
</TD>
<TD>
<p>
Affirmative test result
</p>
</TD>
</TR>
<TR>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
<p>
Not-Processed
</p>
</TD>
<TD>
<p>
Non-Conformant
</p>
</TD>
<TD>
<p>
Application does not process the required element received.
</p>
</TD>
</TR>
<TR>
<TD>
<p>
R
</p>
</TD>
<TD>
<p>
Not-Valued
</p>
</TD>
<TD>
<p>
Raise Exception
</p>
</TD>
<TD>
<p>
Not-Processed; Application raises an exception
</p>
</TD>
<TD>
<p>
Conformant
</p>
</TD>
<TD>
<p>
The application shall raise an error when a required element is not sent. The application should not process the message.
</p>
</TD>
</TR>
<TR>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
<p>
Not processed; no exception raised
</p>
</TD>
<TD>
<p>
Non-Conformant
</p>
</TD>
<TD>
<p>
The application shall raise an error when a required element is not sent. The application should not process the message.
</p>
</TD>
</TR>
<TR>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
<p>
Processed; Application does not raise an exception
</p>
</TD>
<TD>
<p>
Non-Conformant
</p>
</TD>
<TD>
<p>
Application processes the message and does not raise an error for a required element.
</p>
</TD>
</TR>
</TABLE>
<p>
Conformity Assessment of the Required but may be Empty Usage Code for Receiving Applications
</p>
<TABLE border=1>
<TR>
<TD>
<p>
Usage Indicator
</p>
</TD>
<TD>
<p>
Test Data Sent
</p>
</TD>
<TD>
<p>
Conformity Assessment Indicator
</p>
</TD>
<TD>
<p>
Receiver Action
</p>
</TD>
<TD>
<p>
Conformity Assessment
</p>
</TD>
<TD>
<p>
Comments
</p>
</TD>
</TR>
<TR>
<TD>
<p>
RE
</p>
</TD>
<TD>
<p>
Valued
</p>
</TD>
<TD>
<p>
Process Element
</p>
</TD>
<TD>
<p>
Processed
</p>
</TD>
<TD>
<p>
Conformant
</p>
</TD>
<TD>
<p>
Affirmative test result
</p>
</TD>
</TR>
<TR>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
<p>
Not-Processed
</p>
</TD>
<TD>
<p>
Non-Conformant
</p>
</TD>
<TD>
<p>
Application does not process the required element received.
</p>
</TD>
</TR>
<TR>
<TD>
<p>
RE
</p>
</TD>
<TD>
<p>
Not-Valued
</p>
</TD>
<TD>
<p>
Process Message
</p>
</TD>
<TD>
<p>
Not-Processed and/or the application raises an exception
</p>
</TD>
<TD>
<p>
Non-Conformant
</p>
</TD>
<TD>
<p>
Application should process the message when this element is omitted. In this case the application did not process the message and/or raised an exception.
</p>
</TD>
</TR>
<TR>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
<p>
Processed; Application does not raise an exception
</p>
</TD>
<TD>
<p>
Conformant
</p>
</TD>
<TD>
<p>
Application processes the message. Affirmative test result. 
</p>
</TD>
</TR>
</TABLE>
<p>
Conformity Assessment of Not-Supported Usage Code for Receiving Applications
</p>
<TABLE border=1>
<TR>
<TD>
<p>
Usage Indicator
</p>
</TD>
<TD>
<p>
Test Data Sent
</p>
</TD>
<TD>
<p>
Conformity Assessment Indicator
</p>
</TD>
<TD>
<p>
Receiver Action
</p>
</TD>
<TD>
<p>
Conformity Assessment
</p>
</TD>
<TD>
<p>
Comments
</p>
</TD>
</TR>
<TR>
<TD>
<p>
X
</p>
</TD>
<TD>
<p>
Valued
</p>
</TD>
<TD>
<p>
Don''t process the element; Exception may be raised
</p>
</TD>
<TD>
<p>
Element Processed
</p>
</TD>
<TD>
<p>
Non-Conformant
</p>
</TD>
<TD>
<p>
Non-conformant because data was processed for a not-supported element; correct behavior is to not process the element.
</p>
</TD>
</TR>
<TR>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
<p>
Element Not-Processed
</p>
</TD>
<TD>
<p>
Conformant
</p>
</TD>
<TD>
<p>
Application did not process not-supported element.
</p>
</TD>
</TR>
<TR>
<TD>
<p>
X
</p>
</TD>
<TD>
<p>
Not-Valued
</p>
</TD>
<TD>
<p>
Process Message
</p>
</TD>
<TD>
<p>
Application raises an error
</p>
</TD>
<TD>
<p>
Non-Conformant
</p>
</TD>
<TD>
<p>
Application should process the message without raising an exception.
</p>
</TD>
</TR>
<TR>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
<TD>
<p>
Processed
</p>
</TD>
<TD>
<p>
Conformant
</p>
</TD>
<TD>
<p>
Confirms expected behavior. 
</p>
</TD>
</TR>
</TABLE>
<A ID="Heading931" >
<H4>
2B.14.3.0 Conditional (C(a/b)) Usage Conformity Assessment
</H4>
<p>
Conformance assessment for elements with conditional usage (i.e., C(a/b)) is dependent on the result of the condition predicate. For example, if conditional usage for an element is specified as C(R/X) and the result of the condition evaluation is true then the usage for the element is R and the conformity assessment table for R-required applies. Likewise, when the result of the condition evaluation is false then the usage for the element is X and the conformity assessment table for X-not supported applies.
</p>
<p>
When testing elements with conditional usage both the true and false scenarios need to be examined. Conformity assessment tables can be built for the various combinations such as C(R/X), C(R/RE), and so on. See the Conditional Usage Conformity Assessment section for sending application for an example.
</p>
<A ID="Heading932" >
<H4>
2B.14.3.1 Optional (O) Usage Conformance Implications
</H4>
<p>
The usage indicator "O-Optional" must be further constrained to another value in order to allow for a conformity assessment.  Therefore, no truth table is provided. 
</p>
<A ID="Heading933" >
<H2>
2B.15 Message profile document definition 
</H2>
<p>
The structure of the message profile document is expressed using the XML Schema Language.  The message profile schema is normative in order to express the rules by which the registry will validate .
</p>
<A ID="Heading934" >
<H3>
2B.15.1 Message profile schema  
</H3>
<TABLE>
<TR>
<TD>
<p>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
</p>
<p>
&lt;!--
</p>
<p>
    == Changes from previous version (2.7.1)
</p>
<p>
    1. The schema has been updated to reflect the changes introduced in 
</p>
<p>
       the version 2.8 of the standard.  
</p>
<p>
             Below is a summary of the changes   (see the conformance section in the 
</p>
<p>
             standard for more details)
</p>
<p>
            - Use Case element has been replaced with Interaction
</p>
<p>
            - Cardinality of  HL7v2xStaticDef element has been changed from
</p>
<p>
              minOccurs = 1 and maxOccurs = unbounded  to minOccurs = 1 and maxOccurs = 1
</p>
<p>
            - Role attribute has been removed from HL7v2xStaticDef element
</p>
<p>
    2. Field element has been modified to support 
</p>
<p>
         a) profiling repeating elements (See Profiling Repeating Elements for details)
</p>
<p>
         b) profiling elements based on a specific component value
</p>
<p>
--&gt;
</p>
<p>
&lt;!--  
</p>
<p>
    == Issues
</p>
<p>
    1. TableLibraryReference is defined as a black box (xsd:any) any valid xml can be inserted. This may need to be detailed.
</p>
<p>
--&gt;
</p>
<p>
&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified"&gt;
</p>
<p>
&lt;xs:element name="HL7v2xConformanceProfile"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;An unambiguous specification of one or more standard HL7 messages that have been analyzed for a particular use case. It prescribes a set of precise constraints upon one or more standard HL7 messages.&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;xs:complexType&gt;
</p>
<p>
&lt;xs:sequence&gt;
</p>
<p>
&lt;xs:element name="MetaData" type="MetaDataType"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;Provides descriptive information about the life-cycle of the HL7v2xConformanceProfile, as well as authorship and control information.&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;/xs:element&gt;
</p>
<p>
&lt;xs:element name="Annotation" type="AnnotationType" minOccurs="0" maxOccurs="unbounded"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;Annotations provide a general description about how the profile is intended to be used, as well as hints on using or interpreting the profile.&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;/xs:element&gt;
</p>
<p>
&lt;xs:element name="Encodings"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;Identifies all of the message encoding mechanisms supported by the profile. Non-traditional encoding mechanisms may be identified if desired.&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;xs:complexType&gt;
</p>
<p>
&lt;xs:sequence&gt;
</p>
<p>
&lt;xs:element name="Encoding" maxOccurs="unbounded"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;Identifies one of the encoding mechanisms supported by the profile.&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;xs:simpleType&gt;
</p>
<p>
&lt;xs:union memberTypes="xs:NMTOKEN"&gt;
</p>
<p>
&lt;xs:simpleType&gt;
</p>
<p>
&lt;xs:restriction base="xs:NMTOKEN"&gt;
</p>
<p>
&lt;xs:enumeration value="ER7"/&gt;
</p>
<p>
&lt;xs:enumeration value="XML"/&gt;
</p>
<p>
&lt;/xs:restriction&gt;
</p>
<p>
&lt;/xs:simpleType&gt;
</p>
<p>
&lt;/xs:union&gt;
</p>
<p>
&lt;/xs:simpleType&gt;
</p>
<p>
&lt;/xs:element&gt;
</p>
<p>
&lt;/xs:sequence&gt;
</p>
<p>
&lt;/xs:complexType&gt;
</p>
<p>
&lt;xs:key name="EncodingUniqueInEncodings"&gt;
</p>
<p>
&lt;xs:selector xpath="Encoding"/&gt;
</p>
<p>
&lt;xs:field xpath="."/&gt;
</p>
<p>
&lt;/xs:key&gt;
</p>
<p>
&lt;/xs:element&gt;
</p>
<p>
&lt;xs:element name="Interaction"&gt;
</p>
<p>
&lt;xs:complexType&gt;
</p>
<p>
&lt;xs:sequence&gt;
</p>
<p>
&lt;xs:element name="Annotation" type="AnnotationType" minOccurs="0" maxOccurs="unbounded"/&gt;
</p>
<p>
&lt;/xs:sequence&gt;
</p>
<p>
&lt;xs:attribute name="Sender" type="xs:string" use="required"/&gt;
</p>
<p>
&lt;xs:attribute name="Receiver" type="xs:string" use="required"/&gt;
</p>
<p>
&lt;xs:attribute name="Message" type="MsgTypeType" use="required"/&gt;
</p>
<p>
&lt;/xs:complexType&gt;
</p>
<p>
&lt;/xs:element&gt;
</p>
<p>
&lt;xs:element name="DynamicDef" maxOccurs="unbounded"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;The dynamic definition is an interaction specification for a conversation between 2 or more systems.&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;xs:complexType&gt;
</p>
<p>
&lt;xs:attribute name="AccAck" type="AcknowledgementType" default="NE"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;Identifies when and if HL7 ''Accept'' acknowledgements are required. Allowed values are: AL (always), NE (never), SU (on success), ER (on error). Default is ''NE''.&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;/xs:attribute&gt;
</p>
<p>
&lt;xs:attribute name="AppAck" type="AcknowledgementType" default="AL"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;Identifies when and if HL7 ''Application'' acknowledgements are required. Allowed values are: AL (always), NE (never), SU (on success), ER (on error).  Default is ''AL''.&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;/xs:attribute&gt;
</p>
<p>
&lt;xs:attribute name="MsgAckMode" default="Immediate"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;Identifies the type of acknowledgement expected by the sender of a message. Allowed values are: Immediate and Deferred. Default is Immediate.&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;xs:simpleType&gt;
</p>
<p>
&lt;xs:restriction base="xs:NMTOKEN"&gt;
</p>
<p>
&lt;xs:enumeration value="Immediate"/&gt;
</p>
<p>
&lt;xs:enumeration value="Deferred"/&gt;
</p>
<p>
&lt;/xs:restriction&gt;
</p>
<p>
&lt;/xs:simpleType&gt;
</p>
<p>
&lt;/xs:attribute&gt;
</p>
<p>
&lt;xs:attribute name="QueryMessageType" default="NonQuery"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;Identifies whether the message is query-related, and if so, what type of query message it is. Allowed values are: NonQuery, Query, Response and Publish. Default is NonQuery.
</p>
<p>
                                &lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;xs:simpleType&gt;
</p>
<p>
&lt;xs:restriction base="xs:NMTOKEN"&gt;
</p>
<p>
&lt;xs:enumeration value="NonQuery"/&gt;
</p>
<p>
&lt;xs:enumeration value="Query"/&gt;
</p>
<p>
&lt;xs:enumeration value="Response"/&gt;
</p>
<p>
&lt;xs:enumeration value="Publish"/&gt;
</p>
<p>
&lt;/xs:restriction&gt;
</p>
<p>
&lt;/xs:simpleType&gt;
</p>
<p>
&lt;/xs:attribute&gt;
</p>
<p>
&lt;xs:attribute name="QueryMode" default="RealTime"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;Identifies the type of query being performed. Allowed values are: Batch, RealTime or Both.&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;xs:simpleType&gt;
</p>
<p>
&lt;xs:restriction base="xs:NMTOKEN"&gt;
</p>
<p>
&lt;xs:enumeration value="Batch"/&gt;
</p>
<p>
&lt;xs:enumeration value="RealTime"/&gt;
</p>
<p>
&lt;xs:enumeration value="Both"/&gt;
</p>
<p>
&lt;/xs:restriction&gt;
</p>
<p>
&lt;/xs:simpleType&gt;
</p>
<p>
&lt;/xs:attribute&gt;
</p>
<p>
&lt;/xs:complexType&gt;
</p>
<p>
&lt;/xs:element&gt;
</p>
<p>
&lt;xs:element ref="HL7v2xStaticDef"/&gt;
</p>
<p>
&lt;xs:choice&gt;
</p>
<p>
&lt;xs:element name="TableLibrary" type="TableLibraryType"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;The table library specifies a standardized format to organize the vocabulary and provides support to reference it (See section X.X.X ). In short, the table library is a container for a collection of tables. &lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;/xs:element&gt;
</p>
<p>
&lt;xs:element name="TableLibraryReference" type="TableLibraryReferenceType"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation/&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;/xs:element&gt;
</p>
<p>
&lt;/xs:choice&gt;
</p>
<p>
&lt;/xs:sequence&gt;
</p>
<p>
&lt;xs:attribute name="HL7Version" default="2.8"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;Identifies the HL7 2.x version on which the profile is based and with which it is expected to comply.&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;xs:simpleType&gt;
</p>
<p>
&lt;xs:union memberTypes="xs:NMTOKEN"&gt;
</p>
<p>
&lt;xs:simpleType&gt;
</p>
<p>
&lt;xs:restriction base="xs:NMTOKEN"&gt;
</p>
<p>
&lt;xs:enumeration value="2.0"/&gt;
</p>
<p>
&lt;xs:enumeration value="2.0D"/&gt;
</p>
<p>
&lt;xs:enumeration value="2.1"/&gt;
</p>
<p>
&lt;xs:enumeration value="2.2"/&gt;
</p>
<p>
&lt;xs:enumeration value="2.3"/&gt;
</p>
<p>
&lt;xs:enumeration value="2.3.1"/&gt;
</p>
<p>
&lt;xs:enumeration value="2.4"/&gt;
</p>
<p>
&lt;xs:enumeration value="2.5"/&gt;
</p>
<p>
&lt;xs:enumeration value="2.5.1"/&gt;
</p>
<p>
&lt;xs:enumeration value="2.6"/&gt;
</p>
<p>
&lt;xs:enumeration value="2.7"/&gt;
</p>
<p>
&lt;xs:enumeration value="2.7.1"/&gt;
</p>
<p>
&lt;xs:enumeration value="2.8"/&gt;
</p>
<p>
&lt;/xs:restriction&gt;
</p>
<p>
&lt;/xs:simpleType&gt;
</p>
<p>
&lt;/xs:union&gt;
</p>
<p>
&lt;/xs:simpleType&gt;
</p>
<p>
&lt;/xs:attribute&gt;
</p>
<p>
&lt;xs:attribute name="ProfileType" use="required"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;Categorizes the profile into one of 3 types: HL7 - represents a specific HL7 published standard (may only be submitted by the HL7 Organization); Constrainable - May contain "Optional" elements which must be further constrained in order to create implementation profiles; Implementation - Fully constrained with no optionality (reflects the behavior of a runtime system)&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;xs:simpleType&gt;
</p>
<p>
&lt;xs:restriction base="xs:NMTOKEN"&gt;
</p>
<p>
&lt;xs:enumeration value="Implementation"/&gt;
</p>
<p>
&lt;xs:enumeration value="Constrainable"/&gt;
</p>
<p>
&lt;/xs:restriction&gt;
</p>
<p>
&lt;/xs:simpleType&gt;
</p>
<p>
&lt;/xs:attribute&gt;
</p>
<p>
&lt;xs:attribute name="Identiifer" type="IdentifierType"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;A unique identifier for this specific version of this dynamic profile. If not specified, one will be assigned to the profile upon submission to a registry.&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;/xs:attribute&gt;
</p>
<p>
&lt;xs:attribute name="ProfileSchemaVersion" type="xs:float" use="required" fixed="2.0"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;The schema version of the profile.&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;/xs:attribute&gt;
</p>
<p>
&lt;/xs:complexType&gt;
</p>
<p>
&lt;/xs:element&gt;
</p>
<p>
&lt;xs:element name="HL7v2xStaticDef"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;This represents a detailed profile of a single message. It provides a detailed breakdown of exactly what the message may contain, including optionality and cardinality.&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;xs:complexType&gt;
</p>
<p>
&lt;xs:sequence&gt;
</p>
<p>
&lt;xs:element name="MetaData" type="MetaDataType" minOccurs="0"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;Provides descriptive information about the life-cycle of the HL7 v2x Static Definition, as well as authorship and control information.&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;/xs:element&gt;
</p>
<p>
&lt;xs:group ref="MessageGroup"/&gt;
</p>
<p>
&lt;xs:element name="Segment" type="SegmentType"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;Documents the characteristics of a single HL7 segment within the context of a particular message or segment group.&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;/xs:element&gt;
</p>
<p>
&lt;xs:group ref="SegGroupOrSegmentGrouping" maxOccurs="unbounded"/&gt;
</p>
<p>
&lt;/xs:sequence&gt;
</p>
<p>
&lt;xs:attribute name="MsgType" type="MsgTypeType" use="required"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;The HL7 message type code, as identified in MSH-9.1 (see HL7 Table 0076 - Message type).&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;/xs:attribute&gt;
</p>
<p>
&lt;xs:attribute name="EventType" type="EventTypeType" use="required"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;The HL7 event type code, as identified in MSH-9.2 (see HL7 Table 0003 - Event type)&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;/xs:attribute&gt;
</p>
<p>
&lt;xs:attribute name="MsgStructID" type="MsgStructIDType"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;The HL7 message structure code, as identified in MSH-9.3 (see HL7 Table 0354 - Message Structure Type). &lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;/xs:attribute&gt;
</p>
<p>
&lt;xs:attribute name="OrderControl" type="OrderControlType"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;The HL7 Order control code, as identified in ORC 1 (see HL7 Table 0119 - Order Control Codes).&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;/xs:attribute&gt;
</p>
<p>
&lt;xs:attribute name="EventDesc" type="NonEmptyStringType" use="required"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;A description of the event carried by this message.&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;/xs:attribute&gt;
</p>
<p>
&lt;xs:attribute name="Identifier" type="IdentifierType" use="optional"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;A unique identifier for this specific version of this static definition. If not specified, one will be assigned to the profile upon submission to a registry.&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;/xs:attribute&gt;
</p>
<p>
&lt;/xs:complexType&gt;
</p>
<p>
&lt;/xs:element&gt;
</p>
<p>
&lt;xs:complexType name="MetaDataType"&gt;
</p>
<p>
&lt;xs:attribute name="Name" type="NonEmptyStringType" use="required"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;Provides a name that clearly and concisely defines the message exchange being profiled.&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;/xs:attribute&gt;
</p>
<p>
&lt;xs:attribute name="OrgName" type="NonEmptyStringType" use="required"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;Name of the organization that submitted the profile.&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;/xs:attribute&gt;
</p>
<p>
&lt;xs:attribute name="Version" type="NonEmptyStringType" use="optional"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;The version identifier assigned to this profile by the author. There is no prescribed version numbering scheme.  However ''higher'' versions should generally be interpreted to be more resent.&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;/xs:attribute&gt;
</p>
<p>
&lt;xs:attribute name="Status" type="NonEmptyStringType" use="optional"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;Status of this profile, as assigned by the author. There is no prescribed status scheme at this time. Possible values might include: ''Draft'', ''Active'', ''Superceded'', ''Withdrawn''&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;/xs:attribute&gt;
</p>
<p>
&lt;xs:attribute name="Topics" type="NonEmptyStringType" use="optional"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;This provides a list of key-words that relate to the profile and that may be useful in profile searches.&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;/xs:attribute&gt;
</p>
<p>
&lt;xs:attribute name="MetaVersion" default="2.6"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;Identifies the Message Profile version on which the profile is based and with which it is expected to comply.               
</p>
<p>
                &lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;xs:simpleType&gt;
</p>
<p>
&lt;xs:union memberTypes="xs:NMTOKEN"&gt;
</p>
<p>
&lt;xs:simpleType&gt;
</p>
<p>
&lt;xs:restriction base="xs:NMTOKEN"&gt;
</p>
<p>
&lt;xs:enumeration value="2.5"/&gt;
</p>
<p>
&lt;xs:enumeration value="2.6"/&gt;
</p>
<p>
&lt;xs:enumeration value="2.7"/&gt;
</p>
<p>
&lt;xs:enumeration value="2.7.1"/&gt;
</p>
<p>
&lt;xs:enumeration value="2.8"/&gt;
</p>
<p>
&lt;/xs:restriction&gt;
</p>
<p>
&lt;/xs:simpleType&gt;
</p>
<p>
&lt;/xs:union&gt;
</p>
<p>
&lt;/xs:simpleType&gt;
</p>
<p>
&lt;/xs:attribute&gt;
</p>
<p>
&lt;xs:attribute name="Context" type="NonEmptyStringType" use="optional"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;As defined, in the HL7 Policies and Procedures Manual, Affiliates will have decision-making authority.  HL7 Affiliates control Realms.  Realms do not have decision-making authority.  Realms simply represent a partition of the solution space.  Affiliates choose how the solution space is to be partitioned by authorizing the creation of zero to many (0..*) Realms.&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;/xs:attribute&gt;
</p>
<p>
&lt;/xs:complexType&gt;
</p>
<p>
&lt;xs:group name="SegGroupOrSegmentGrouping"&gt;
</p>
<p>
&lt;xs:choice&gt;
</p>
<p>
&lt;xs:element name="SegGroup"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;Documents the characteristics of a grouping of HL7 segments within the context of a particular message or segment group.&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;xs:complexType&gt;
</p>
<p>
&lt;xs:sequence&gt;
</p>
<p>
&lt;xs:group ref="MessageElementsGroup"/&gt;
</p>
<p>
&lt;xs:group ref="SegGroupOrSegmentGrouping" maxOccurs="unbounded"/&gt;
</p>
<p>
&lt;/xs:sequence&gt;
</p>
<p>
&lt;xs:attribute name="Name" use="required"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;This is the short, formal name for the group. It appears in the tag name when using the XML Encoding syntax.&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;xs:simpleType&gt;
</p>
<p>
&lt;xs:restriction base="xs:NMTOKEN"&gt;
</p>
<p>
&lt;xs:pattern value="([A-Z]|_)+"/&gt;
</p>
<p>
&lt;/xs:restriction&gt;
</p>
<p>
&lt;/xs:simpleType&gt;
</p>
<p>
&lt;/xs:attribute&gt;
</p>
<p>
&lt;xs:attribute ref="LongName" use="required"/&gt;
</p>
<p>
&lt;xs:attribute ref="Usage" use="required"/&gt;
</p>
<p>
&lt;xs:attribute ref="PredicateTrueUsage"/&gt;
</p>
<p>
&lt;xs:attribute ref="PredicateFalseUsage"/&gt;
</p>
<p>
&lt;xs:attributeGroup ref="RepeatableElementAttributes"/&gt;
</p>
<p>
&lt;/xs:complexType&gt;
</p>
<p>
&lt;/xs:element&gt;
</p>
<p>
&lt;xs:element name="Segment" type="SegmentType"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;Documents the characteristics of a single HL7 segment within the context of a particular message or segment group.&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;/xs:element&gt;
</p>
<p>
&lt;/xs:choice&gt;
</p>
<p>
&lt;/xs:group&gt;
</p>
<p>
&lt;xs:complexType name="SegmentType"&gt;
</p>
<p>
&lt;xs:sequence&gt;
</p>
<p>
&lt;xs:group ref="MessageElementsGroup"/&gt;
</p>
<p>
&lt;xs:element name="Field" maxOccurs="unbounded"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;Documents the characteristics of a single HL7 field within the context of a particular message segment.&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;xs:complexType&gt;
</p>
<p>
&lt;xs:sequence&gt;
</p>
<p>
&lt;xs:group ref="LeafMessageElementsGroup"/&gt;
</p>
<p>
&lt;xs:element name="Occurrence" minOccurs="0" maxOccurs="unbounded"&gt;
</p>
<p>
&lt;xs:complexType&gt;
</p>
<p>
&lt;xs:sequence&gt;
</p>
<p>
&lt;xs:element name="Component" minOccurs="0" maxOccurs="unbounded"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;Documents the characteristics of a single component within the context of a field.&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;xs:complexType&gt;
</p>
<p>
&lt;xs:sequence&gt;
</p>
<p>
&lt;xs:group ref="LeafMessageElementsGroup"/&gt;
</p>
<p>
&lt;xs:element name="SubComponent" minOccurs="0" maxOccurs="unbounded"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;Documents the characteristics of a single sub-component within the context of a component.&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;xs:complexType&gt;
</p>
<p>
&lt;xs:group ref="LeafMessageElementsGroup"/&gt;
</p>
<p>
&lt;xs:attributeGroup ref="LeafElementAttributes"/&gt;
</p>
<p>
&lt;/xs:complexType&gt;
</p>
<p>
&lt;/xs:element&gt;
</p>
<p>
&lt;/xs:sequence&gt;
</p>
<p>
&lt;xs:attributeGroup ref="LeafElementAttributes"/&gt;
</p>
<p>
&lt;/xs:complexType&gt;
</p>
<p>
&lt;/xs:element&gt;
</p>
<p>
&lt;/xs:sequence&gt;
</p>
<p>
&lt;xs:attribute name="Number" type="xs:nonNegativeInteger"/&gt;
</p>
<p>
&lt;xs:attribute name="Value" type="xs:string"/&gt;
</p>
<p>
&lt;/xs:complexType&gt;
</p>
<p>
&lt;/xs:element&gt;
</p>
<p>
&lt;/xs:sequence&gt;
</p>
<p>
&lt;xs:attributeGroup ref="RepeatableElementAttributes"/&gt;
</p>
<p>
&lt;xs:attributeGroup ref="LeafElementAttributes"/&gt;
</p>
<p>
&lt;xs:attribute name="ItemNo"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;The HL7-assigned item number corresponding with the semantic meaning of the field.&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;xs:simpleType&gt;
</p>
<p>
&lt;xs:restriction base="xs:NMTOKEN"&gt;
</p>
<p>
&lt;xs:pattern value="\d{5}"/&gt;
</p>
<p>
&lt;/xs:restriction&gt;
</p>
<p>
&lt;/xs:simpleType&gt;
</p>
<p>
&lt;/xs:attribute&gt;
</p>
<p>
&lt;xs:attribute name="Order" type="xs:boolean"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;Specifies if order apply or not when profiling repeating fields.&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;/xs:attribute&gt;
</p>
<p>
&lt;xs:attribute name="Position" type="xs:nonNegativeInteger"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;Specifies the position of the component which value is referred to in the Occurrence element &lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;/xs:attribute&gt;
</p>
<p>
&lt;/xs:complexType&gt;
</p>
<p>
&lt;/xs:element&gt;
</p>
<p>
&lt;/xs:sequence&gt;
</p>
<p>
&lt;xs:attribute name="Name" type="SegmentNameType" use="required"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;This is the short, formal name for the segment. It is used to identify the segment in both ER7 and XML encodings.&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;/xs:attribute&gt;
</p>
<p>
&lt;xs:attribute ref="LongName"/&gt;
</p>
<p>
&lt;xs:attribute ref="Usage" use="required"/&gt;
</p>
<p>
&lt;xs:attribute ref="PredicateTrueUsage"/&gt;
</p>
<p>
&lt;xs:attribute ref="PredicateFalseUsage"/&gt;
</p>
<p>
&lt;xs:attributeGroup ref="RepeatableElementAttributes"/&gt;
</p>
<p>
&lt;/xs:complexType&gt;
</p>
<p>
&lt;xs:complexType name="AnnotationType"&gt;
</p>
<p>
&lt;xs:simpleContent&gt;
</p>
<p>
&lt;xs:extension base="NonEmptyStringType"&gt;
</p>
<p>
&lt;xs:attributeGroup ref="AnnotationAttributes"/&gt;
</p>
<p>
&lt;/xs:extension&gt;
</p>
<p>
&lt;/xs:simpleContent&gt;
</p>
<p>
&lt;/xs:complexType&gt;
</p>
<p>
&lt;xs:attributeGroup name="LeafElementAttributes"&gt;
</p>
<p>
&lt;xs:attribute name="Name" type="NonEmptyStringType" use="required"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;The descriptive name for the field/component/sub-component&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;/xs:attribute&gt;
</p>
<p>
&lt;xs:attribute ref="Usage" use="required"/&gt;
</p>
<p>
&lt;xs:attribute ref="PredicateTrueUsage"/&gt;
</p>
<p>
&lt;xs:attribute ref="PredicateFalseUsage"/&gt;
</p>
<p>
&lt;xs:attribute name="Datatype" type="DatatypeType" use="required"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;Identifies the HL7 datatype associated with the element.&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;/xs:attribute&gt;
</p>
<p>
&lt;xs:attribute name="MinLength" type="xs:positiveInteger"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;Identifies the minimum allowed length for the content of the element.&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;/xs:attribute&gt;
</p>
<p>
&lt;xs:attribute name="MaxLength" type="xs:positiveInteger"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;Identifies the maximum allowed length for the content of the element.&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;/xs:attribute&gt;
</p>
<p>
&lt;xs:attribute name="ConformanceLength" type="xs:positiveInteger"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;The minimum length an application must be able to handle&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;/xs:attribute&gt;
</p>
<p>
&lt;xs:attribute name="Truncation" type="xs:boolean"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;whether the truncation pattern does/may apply&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;/xs:attribute&gt;
</p>
<p>
&lt;xs:attribute name="Table" type="TableType"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;Identifies the name of the table associated with the content of this element.&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;/xs:attribute&gt;
</p>
<p>
&lt;xs:attribute name="ConstantValue" type="NonEmptyStringType"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;Identifies the fixed value associated with this element&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;!-- Can only have constant values for leaf elements --&gt;
</p>
<p>
&lt;/xs:attribute&gt;
</p>
<p>
&lt;/xs:attributeGroup&gt;
</p>
<p>
&lt;xs:attributeGroup name="RepeatableElementAttributes"&gt;
</p>
<p>
&lt;xs:attribute name="Min" type="xs:nonNegativeInteger" use="required"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;This identifies the minimum number of repetitions of the element that are permitted in a message instance. This attribute should only be specified if the minimum number of repetitions is greater than 1, as the minimum for other elements is always ''0''.&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;/xs:attribute&gt;
</p>
<p>
&lt;xs:attribute name="Max" use="required"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;This identifies the maximum number of repetitions of the element that are permitted in a message instance. This attribute should only be specified if the maximum number of repetitions is greater than 1 and differs from the minimum attribute (i.e. the maximum number of repetitions is greater than the minimum number of repetitions). The special value ''*'' may be used to represent ''unlimited'' repetitions.&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;xs:simpleType&gt;
</p>
<p>
&lt;xs:union&gt;
</p>
<p>
&lt;xs:simpleType&gt;
</p>
<p>
&lt;xs:restriction base="xs:positiveInteger"&gt;
</p>
<p>
&lt;xs:minInclusive value="1"/&gt;
</p>
<p>
&lt;/xs:restriction&gt;
</p>
<p>
&lt;/xs:simpleType&gt;
</p>
<p>
&lt;xs:simpleType&gt;
</p>
<p>
&lt;xs:restriction base="xs:string"&gt;
</p>
<p>
&lt;xs:enumeration value="*"/&gt;
</p>
<p>
&lt;/xs:restriction&gt;
</p>
<p>
&lt;/xs:simpleType&gt;
</p>
<p>
&lt;/xs:union&gt;
</p>
<p>
&lt;/xs:simpleType&gt;
</p>
<p>
&lt;/xs:attribute&gt;
</p>
<p>
&lt;/xs:attributeGroup&gt;
</p>
<p>
&lt;xs:attributeGroup name="AnnotationAttributes"&gt;
</p>
<p>
&lt;xs:attribute name="Type" use="required"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;
</p>
<p>
                &lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;xs:simpleType&gt;
</p>
<p>
&lt;xs:union memberTypes="xs:NMTOKEN"&gt;
</p>
<p>
&lt;xs:simpleType&gt;
</p>
<p>
&lt;xs:restriction base="xs:NMTOKEN"&gt;
</p>
<p>
&lt;xs:enumeration value="ImpNote"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;Implementation Notes provide a general description about how the element is intended to be used, as well as hints on using or interpreting the it.&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;/xs:enumeration&gt;
</p>
<p>
&lt;xs:enumeration value="Description"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt; An explanation of the associated element.&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;/xs:enumeration&gt;
</p>
<p>
&lt;xs:enumeration value="Definition"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt; An explanation of the meaning of the element.&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;/xs:enumeration&gt;
</p>
<p>
&lt;xs:enumeration value="DesignComment"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt; Internal development notes about why particular design decisions were made, outstanding issues and remaining work.  They may contain formatting markup.  Not intended for external publication.&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;/xs:enumeration&gt;
</p>
<p>
&lt;xs:enumeration value="Other"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt; Additional content related to the element.&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;/xs:enumeration&gt;
</p>
<p>
&lt;xs:enumeration value="Example"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt; An example instance of the element.&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;/xs:enumeration&gt;
</p>
<p>
&lt;/xs:restriction&gt;
</p>
<p>
&lt;/xs:simpleType&gt;
</p>
<p>
&lt;/xs:union&gt;
</p>
<p>
&lt;/xs:simpleType&gt;
</p>
<p>
&lt;/xs:attribute&gt;
</p>
<p>
&lt;xs:attribute name="OtherIdentifier" type="NonEmptyStringType"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation/&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;/xs:attribute&gt;
</p>
<p>
&lt;/xs:attributeGroup&gt;
</p>
<p>
&lt;xs:group name="MessageGroup"&gt;
</p>
<p>
&lt;xs:sequence&gt;
</p>
<p>
&lt;xs:element name="Annotation" type="AnnotationType" minOccurs="0" maxOccurs="unbounded"/&gt;
</p>
<p>
&lt;xs:element name="Description" type="NonEmptyStringType" minOccurs="0"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;Provides an explanation or definition of what the element represents.&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;/xs:element&gt;
</p>
<p>
&lt;xs:element name="Reference" minOccurs="0"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;Identifies external sources or other locations within the profile where additional information can be found about this item.&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;xs:simpleType&gt;
</p>
<p>
&lt;xs:restriction base="NonEmptyStringType"/&gt;
</p>
<p>
&lt;/xs:simpleType&gt;
</p>
<p>
&lt;/xs:element&gt;
</p>
<p>
&lt;/xs:sequence&gt;
</p>
<p>
&lt;/xs:group&gt;
</p>
<p>
&lt;xs:group name="MessageElementsGroup"&gt;
</p>
<p>
&lt;xs:sequence&gt;
</p>
<p>
&lt;xs:group ref="MessageGroup"/&gt;
</p>
<p>
&lt;xs:element name="Predicate" minOccurs="0"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;Identifies the conditionality rule for this element, if applicable&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;xs:simpleType&gt;
</p>
<p>
&lt;xs:restriction base="NonEmptyStringType"/&gt;
</p>
<p>
&lt;/xs:simpleType&gt;
</p>
<p>
&lt;/xs:element&gt;
</p>
<p>
&lt;/xs:sequence&gt;
</p>
<p>
&lt;/xs:group&gt;
</p>
<p>
&lt;xs:group name="LeafMessageElementsGroup"&gt;
</p>
<p>
&lt;xs:sequence&gt;
</p>
<p>
&lt;xs:group ref="MessageElementsGroup"/&gt;
</p>
<p>
&lt;xs:element name="DataValues" minOccurs="0" maxOccurs="unbounded"&gt;
</p>
<p>
&lt;xs:complexType&gt;
</p>
<p>
&lt;xs:attribute name="ExValue" type="NonEmptyStringType"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;Identifies an individual example value.&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;/xs:attribute&gt;
</p>
<p>
&lt;/xs:complexType&gt;
</p>
<p>
&lt;/xs:element&gt;
</p>
<p>
&lt;/xs:sequence&gt;
</p>
<p>
&lt;/xs:group&gt;
</p>
<p>
&lt;xs:attribute name="LongName" type="NonEmptyStringType"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;This is the descriptive name for the element. It does not appear in any encodings.&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;/xs:attribute&gt;
</p>
<p>
&lt;xs:attribute name="Usage"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;Usage identifies the circumstances under which an element appears in a message. Possible values are: 
</p>
<p>
                R - Required (must always be present); 
</p>
<p>
                RE - Required or Empty (must be present if available); 
</p>
<p>
                O - Optional (no guidance on when the element should appear); 
</p>
<p>
                C - Conditional (the element is required or allowed to be present when the condition specified in the Predicate element is true);
</p>
<p>
                X - Not supported (the element is not supported)
</p>
<p>
            &lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;xs:simpleType&gt;
</p>
<p>
&lt;xs:restriction base="xs:NMTOKEN"&gt;
</p>
<p>
&lt;xs:enumeration value="R"/&gt;
</p>
<p>
&lt;xs:enumeration value="RE"/&gt;
</p>
<p>
&lt;xs:enumeration value="O"/&gt;
</p>
<p>
&lt;xs:enumeration value="C"/&gt;
</p>
<p>
&lt;xs:enumeration value="X"/&gt;
</p>
<p>
&lt;/xs:restriction&gt;
</p>
<p>
&lt;/xs:simpleType&gt;
</p>
<p>
&lt;/xs:attribute&gt;
</p>
<p>
&lt;xs:attribute name="PredicateTrueUsage"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;PredicateTrueUsage is used in combination with a conditional "C" usage . It specifies how the element usage should be interpreted when the condition predicate evaluates to TRUE. Possible values are :
</p>
<p>
                R - Required (must always be present);
</p>
<p>
                RE - Required or Empty (must be present if available);
</p>
<p>
                O - Optional (no guidance on when the element should appear);
</p>
<p>
                X - Not supported (the element is not supported)
</p>
<p>
            &lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;xs:simpleType&gt;
</p>
<p>
&lt;xs:restriction base="xs:NMTOKEN"&gt;
</p>
<p>
&lt;xs:enumeration value="R"/&gt;
</p>
<p>
&lt;xs:enumeration value="RE"/&gt;
</p>
<p>
&lt;xs:enumeration value="O"/&gt;
</p>
<p>
&lt;xs:enumeration value="X"/&gt;
</p>
<p>
&lt;/xs:restriction&gt;
</p>
<p>
&lt;/xs:simpleType&gt;
</p>
<p>
&lt;/xs:attribute&gt;
</p>
<p>
&lt;xs:attribute name="PredicateFalseUsage"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;PredicateFalseUsage is used in combination with a conditional "C" usage . It specifies how the element usage should be interpreted when the condition predicate evaluates to FALSE. Possible values are :
</p>
<p>
                R - Required (must always be present);
</p>
<p>
                RE - Required or Empty (must be present if available);
</p>
<p>
                O - Optional (no guidance on when the element should appear);
</p>
<p>
                X - Not supported (the element is not supported)
</p>
<p>
            &lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;xs:simpleType&gt;
</p>
<p>
&lt;xs:restriction base="xs:NMTOKEN"&gt;
</p>
<p>
&lt;xs:enumeration value="R"/&gt;
</p>
<p>
&lt;xs:enumeration value="RE"/&gt;
</p>
<p>
&lt;xs:enumeration value="O"/&gt;
</p>
<p>
&lt;xs:enumeration value="X"/&gt;
</p>
<p>
&lt;/xs:restriction&gt;
</p>
<p>
&lt;/xs:simpleType&gt;
</p>
<p>
&lt;/xs:attribute&gt;
</p>
<p>
&lt;xs:simpleType name="NonEmptyStringType"&gt;
</p>
<p>
&lt;xs:restriction base="xs:string"&gt;
</p>
<p>
&lt;xs:minLength value="1"/&gt;
</p>
<p>
&lt;/xs:restriction&gt;
</p>
<p>
&lt;/xs:simpleType&gt;
</p>
<p>
&lt;xs:simpleType name="AcknowledgementType"&gt;
</p>
<p>
&lt;xs:restriction base="xs:NMTOKEN"&gt;
</p>
<p>
&lt;xs:enumeration value="AL"/&gt;
</p>
<p>
&lt;xs:enumeration value="NE"/&gt;
</p>
<p>
&lt;xs:enumeration value="SU"/&gt;
</p>
<p>
&lt;xs:enumeration value="ER"/&gt;
</p>
<p>
&lt;/xs:restriction&gt;
</p>
<p>
&lt;/xs:simpleType&gt;
</p>
<p>
&lt;xs:simpleType name="IdentifierType"&gt;
</p>
<p>
&lt;xs:restriction base="xs:NMTOKEN"&gt;
</p>
<p>
&lt;xs:pattern value="(0|[1-9][0-9]*)(\.(0|[1-9][0-9]*))*"/&gt;
</p>
<p>
&lt;/xs:restriction&gt;
</p>
<p>
&lt;/xs:simpleType&gt;
</p>
<p>
&lt;xs:simpleType name="MsgTypeType"&gt;
</p>
<p>
&lt;xs:restriction base="xs:NMTOKEN"&gt;
</p>
<p>
&lt;xs:pattern value="[A-Z0-9]{3}"/&gt;
</p>
<p>
&lt;/xs:restriction&gt;
</p>
<p>
&lt;/xs:simpleType&gt;
</p>
<p>
&lt;xs:simpleType name="EventTypeType"&gt;
</p>
<p>
&lt;xs:restriction base="xs:NMTOKEN"&gt;
</p>
<p>
&lt;xs:pattern value="[A-Z0-9]{3}"/&gt;
</p>
<p>
&lt;/xs:restriction&gt;
</p>
<p>
&lt;/xs:simpleType&gt;
</p>
<p>
&lt;xs:simpleType name="MsgStructIDType"&gt;
</p>
<p>
&lt;xs:restriction base="xs:NMTOKEN"&gt;
</p>
<p>
&lt;xs:pattern value="[A-Z0-9]{3}(_[A-Z0-9]{3})?"/&gt;
</p>
<p>
&lt;/xs:restriction&gt;
</p>
<p>
&lt;/xs:simpleType&gt;
</p>
<p>
&lt;xs:simpleType name="OrderControlType"&gt;
</p>
<p>
&lt;xs:restriction base="xs:NMTOKEN"&gt;
</p>
<p>
&lt;xs:pattern value="[A-Z]{2}"/&gt;
</p>
<p>
&lt;/xs:restriction&gt;
</p>
<p>
&lt;/xs:simpleType&gt;
</p>
<p>
&lt;xs:simpleType name="DatatypeType"&gt;
</p>
<p>
&lt;xs:restriction base="xs:NMTOKEN"&gt;
</p>
<p>
&lt;xs:minLength value="1"/&gt;
</p>
<p>
&lt;/xs:restriction&gt;
</p>
<p>
&lt;/xs:simpleType&gt;
</p>
<p>
&lt;xs:simpleType name="SegmentNameType"&gt;
</p>
<p>
&lt;xs:restriction base="xs:NMTOKEN"&gt;
</p>
<p>
&lt;xs:pattern value="[A-Z][A-Z0-9]{2}"/&gt;
</p>
<p>
&lt;/xs:restriction&gt;
</p>
<p>
&lt;/xs:simpleType&gt;
</p>
<p>
&lt;xs:simpleType name="TableType"&gt;
</p>
<p>
&lt;xs:restriction base="xs:NMTOKEN"&gt;
</p>
<p>
&lt;xs:minLength value="1"/&gt;
</p>
<p>
&lt;/xs:restriction&gt;
</p>
<p>
&lt;/xs:simpleType&gt;
</p>
<p>
&lt;xs:complexType name="TableLibraryType"&gt;
</p>
<p>
&lt;xs:sequence&gt;
</p>
<p>
&lt;xs:element name="TableDefinition" type="TableDefinitionType" maxOccurs="unbounded"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;A table definition consists of metadata describing the table and specifies a list of code/value pairs.  The table definition metadata consists of a table identifier, OID, name, type, version, and code system. &lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;/xs:element&gt;
</p>
<p>
&lt;/xs:sequence&gt;
</p>
<p>
&lt;xs:attribute name="Name" type="xs:string" use="required"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;The name of the table library.&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;/xs:attribute&gt;
</p>
<p>
&lt;xs:attribute name="OrganizationName" type="xs:string"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;The organization that created the library.&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;/xs:attribute&gt;
</p>
<p>
&lt;xs:attribute name="TableLibraryVersion" type="xs:string"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;The version of the table library.&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;/xs:attribute&gt;
</p>
<p>
&lt;xs:attribute name="Status" type="xs:string"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;The status of the table library.&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;/xs:attribute&gt;
</p>
<p>
&lt;xs:attribute name="TableLibraryIdentifier" type="xs:string" use="required"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;A unique identifier for the table library.&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;/xs:attribute&gt;
</p>
<p>
&lt;xs:attribute name="Description" type="xs:string"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;A text description of the table library.&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;/xs:attribute&gt;
</p>
<p>
&lt;/xs:complexType&gt;
</p>
<p>
&lt;xs:complexType name="TableLibraryReferenceType"&gt;
</p>
<p>
&lt;xs:sequence&gt;
</p>
<p>
&lt;xs:any maxOccurs="unbounded"/&gt;
</p>
<p>
&lt;/xs:sequence&gt;
</p>
<p>
&lt;/xs:complexType&gt;
</p>
<p>
&lt;xs:complexType name="TableDefinitionType"&gt;
</p>
<p>
&lt;xs:sequence&gt;
</p>
<p>
&lt;xs:element name="TableElement" type="TableElementType" maxOccurs="unbounded"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;Table elements express code/value pairs and descriptive information about the code/value pair&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;/xs:element&gt;
</p>
<p>
&lt;/xs:sequence&gt;
</p>
<p>
&lt;xs:attribute name="Identifier" type="xs:string" use="required"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;The table identifier.&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;/xs:attribute&gt;
</p>
<p>
&lt;xs:attribute name="OID" type="xs:string" use="required"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;An OID that identify the table, not the codesystem.&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;/xs:attribute&gt;
</p>
<p>
&lt;xs:attribute name="Name" type="xs:string" use="required"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;A descriptive name of the table.&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;/xs:attribute&gt;
</p>
<p>
&lt;xs:attribute name="Type" use="required"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;The type of the table as described in section 2.6.3.6 
</p>
<p>
                    Valid identifiers for a table type are HL7, User, Local, External, and Imported.  &lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;xs:simpleType&gt;
</p>
<p>
&lt;xs:restriction base="xs:string"&gt;
</p>
<p>
&lt;xs:enumeration value="HL7"/&gt;
</p>
<p>
&lt;xs:enumeration value="User"/&gt;
</p>
<p>
&lt;xs:enumeration value="Local"/&gt;
</p>
<p>
&lt;xs:enumeration value="External"/&gt;
</p>
<p>
&lt;xs:enumeration value="Imported"/&gt;
</p>
<p>
&lt;/xs:restriction&gt;
</p>
<p>
&lt;/xs:simpleType&gt;
</p>
<p>
&lt;/xs:attribute&gt;
</p>
<p>
&lt;xs:attribute name="Version" type="xs:string" use="required"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;The version of the table.&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;/xs:attribute&gt;
</p>
<p>
&lt;xs:attribute name="CodeSystem" type="xs:string" use="required"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;A code system as specified in HL7 table 0396 &lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;/xs:attribute&gt;
</p>
<p>
&lt;/xs:complexType&gt;
</p>
<p>
&lt;xs:complexType name="TableElementType"&gt;
</p>
<p>
&lt;xs:attribute name="Code" type="xs:string" use="required"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;The code for the data value.&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;/xs:attribute&gt;
</p>
<p>
&lt;xs:attribute name="DisplayName" type="xs:string" use="required"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;The long description of the code.&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;/xs:attribute&gt;
</p>
<p>
&lt;xs:attribute name="Source" use="required"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;The source of the code/value pair.&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;xs:simpleType&gt;
</p>
<p>
&lt;xs:restriction base="xs:string"&gt;
</p>
<p>
&lt;xs:enumeration value="HL7"/&gt;
</p>
<p>
&lt;xs:enumeration value="Local"/&gt;
</p>
<p>
&lt;xs:enumeration value="Redefined"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;Redefined means the code/display name has been changed from its original value.&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;/xs:enumeration&gt;
</p>
<p>
&lt;xs:enumeration value="SDO"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;SDO means Standard Development Organization.&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;/xs:enumeration&gt;
</p>
<p>
&lt;/xs:restriction&gt;
</p>
<p>
&lt;/xs:simpleType&gt;
</p>
<p>
&lt;/xs:attribute&gt;
</p>
<p>
&lt;/xs:complexType&gt;
</p>
<p>
&lt;/xs:schema&gt;
</p>
</TD>
</TR>
</TABLE>
<A ID="Heading935" >
<H3>
2B.15.2 Table Librarydocument definition
</H3>
<p>
The structure of the table library document is expressedusing the XML Schema Language. The table library schema is normative in order to express the rules by which the registry will validate.
</p>
<TABLE>
<TR>
<TD>
<p>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
</p>
<p>
&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
</p>
<p>
&lt;xs:element name="TableLibrary" type="TableLibraryType"/&gt;
</p>
<p>
&lt;xs:complexType name="TableLibraryType"&gt;
</p>
<p>
&lt;xs:sequence&gt;
</p>
<p>
&lt;xs:element name="TableDefinition" type="TableDefinitionType" maxOccurs="unbounded"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;A table definition consists of metadata describing the table and specifies a list code/value pairs. The table definition metadata consists of a table identifier, name, type, version, and code system. &lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;/xs:element&gt;
</p>
<p>
&lt;/xs:sequence&gt;
</p>
<p>
&lt;xs:attribute name="Name" type="xs:string" use="required"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;The name of the table library.&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;/xs:attribute&gt;
</p>
<p>
&lt;xs:attribute name="OrganizationName" type="xs:string"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;The organization that created the library.&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;/xs:attribute&gt;
</p>
<p>
&lt;xs:attribute name="HL7Version" type="xs:string" use="required"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;The HL7 Version of the table definitions.&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;/xs:attribute&gt;
</p>
<p>
&lt;xs:attribute name="TableLibraryVersion" type="xs:string"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;The version of the table library.&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;/xs:attribute&gt;
</p>
<p>
&lt;xs:attribute name="Status" type="xs:string"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;The status of the table library.&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;/xs:attribute&gt;
</p>
<p>
&lt;xs:attribute name="TableLibraryIdentifier" type="xs:string" use="required"/&gt;
</p>
<p>
&lt;xs:attribute name="Description" type="xs:string"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;A text description of the table library.&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;/xs:attribute&gt;
</p>
<p>
&lt;/xs:complexType&gt;
</p>
<p>
&lt;xs:complexType name="TableDefinitionType"&gt;
</p>
<p>
&lt;xs:sequence&gt;
</p>
<p>
&lt;xs:element name="TableElement" type="TableElementType" maxOccurs="unbounded"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;Table elements express code/value pairs and descriptive information about the code/value pair&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;/xs:element&gt;
</p>
<p>
&lt;/xs:sequence&gt;
</p>
<p>
&lt;xs:attribute name="Identifier" type="xs:string" use="required"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;The table identifier.&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;/xs:attribute&gt;
</p>
<p>
&lt;xs:attribute name="Name" type="xs:string" use="required"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;The name of the table.&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;/xs:attribute&gt;
</p>
<p>
&lt;xs:attribute name="Version" type="xs:string" use="required"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;The version of the specific table.&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;/xs:attribute&gt;
</p>
<p>
&lt;xs:attribute name="CodeSys" type="xs:string" use="required"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;A code system as specified in HL7 table 0396 &lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;/xs:attribute&gt;
</p>
<p>
&lt;xs:attribute name="Type" use="required"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;The table type is a recognized HL7 table as described in section 2.6.3.6. Valid identifiers for a table type are HL7, User, Local, External, and Imported.  &lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;xs:simpleType&gt;
</p>
<p>
&lt;xs:restriction base="xs:string"&gt;
</p>
<p>
&lt;xs:enumeration value="HL7"/&gt;
</p>
<p>
&lt;xs:enumeration value="User"/&gt;
</p>
<p>
&lt;xs:enumeration value="Local"/&gt;
</p>
<p>
&lt;xs:enumeration value="External"/&gt;
</p>
<p>
&lt;xs:enumeration value="Imported"/&gt;
</p>
<p>
&lt;/xs:restriction&gt;
</p>
<p>
&lt;/xs:simpleType&gt;
</p>
<p>
&lt;/xs:attribute&gt;
</p>
<p>
&lt;/xs:complexType&gt;
</p>
<p>
&lt;xs:complexType name="TableElementType"&gt;
</p>
<p>
&lt;xs:attribute name="Code" type="xs:string" use="required"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;The code for the data value.&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;/xs:attribute&gt;
</p>
<p>
&lt;xs:attribute name="DisplayName" type="xs:string" use="required"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;The long description of the code.&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;/xs:attribute&gt;
</p>
<p>
&lt;xs:attribute name="Source" use="required"&gt;
</p>
<p>
&lt;xs:annotation&gt;
</p>
<p>
&lt;xs:documentation&gt;The source of the code/value pair.&lt;/xs:documentation&gt;
</p>
<p>
&lt;/xs:annotation&gt;
</p>
<p>
&lt;xs:simpleType&gt;
</p>
<p>
&lt;xs:restriction base="xs:string"&gt;
</p>
<p>
&lt;xs:enumeration value="HL7"/&gt;
</p>
<p>
&lt;xs:enumeration value="Local"/&gt;
</p>
<p>
&lt;xs:enumeration value="Redefined"/&gt;
</p>
<p>
&lt;xs:enumeration value="SDO"/&gt;
</p>
<p>
&lt;/xs:restriction&gt;
</p>
<p>
&lt;/xs:simpleType&gt;
</p>
<p>
&lt;/xs:attribute&gt;
</p>
<p>
&lt;/xs:complexType&gt;
</p>
<p>
&lt;/xs:schema&gt;
</p>
</TD>
</TR>
</TABLE>
</BODY>
</HTML>
